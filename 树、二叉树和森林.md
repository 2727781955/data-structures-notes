---

author: Fang
date: 2025-04-12
tags:
  
---
本节我们来学习树这种数据结构
- 树型结构是一类重要的**非线性数据结构**；其中以树和二叉树最为常用，直观看来，树是以分支关系定义的层次结构
- 树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示；树在计算机领域中也得到广泛应用，如在编译程序中，可用树来表示源程序的语法结构；又如在数据库系统中，树形结构也是信息的重要组织形式之一

接下来，将依次介绍树、二叉树和森林这三种树形数据结构

# 一、树
## 1.树的逻辑结构
### 1.1树的定义和相关概念
- 树是n个结点的**有限集**
- 若n = 0，称为空树
- 若n > 0，则它满足以下两个条件：
	- 有且仅有一个特定的称为**根(Root)的结点**
	- 其余结点可分为m个互不相交的有限集$T_1，T_2，T_3.....T_m$，每一个集合本身又是一棵树，并称为根的**子树(SubTree)**
![[Pasted image 20260114234509.png]]

- 如上图：A是根节点，其余分为三个互不相交的集合，即子树：$T_1=\{B、E、F、K、L\}、T_2=\{C、G\}、T_3=\{D、H、I、J、M\}$；在$T_1$中，B为根节点，其余又可分为两个集合，即两个子树

- 结点：数据元素以及指向子树的分支
	- **根节点**：非空树中无前驱结点的结点
	- **叶子结点**（终端结点）：度为零的结点
	- **分支结点**：度不为零的结点

- 度：
	- **结点的度**：某个结点拥有的子树的数量
	- **树的度**：树内各结点的度的最大值

- 树的**深度**：树中结点的最大层次

**树结点之间的关系**
- 某个结点的子树称为该结点的**孩子**结点，该结点称为孩子结点的**双亲**结点
- 如果某些结点有**共同的双亲**，则称它们为**兄弟**结点
- 某些结点，虽然没有共同的双亲，但是它们的双亲在同一层，则称它们为**堂兄弟**结点

**有序与无序**
- **有序树**：树中结点各子树从左向右，按照一定次序排列（最左边为按照次序的第一个孩子）
- **无序树**：树中结点的各子树无次序

**树与森林**
- m（m>=0）棵**互不相交**的树集合
- 将一棵树的根节点删除，剩余子树互不相交，也就变成了森林
- 对于一棵树，可以看作是一个特殊的森林；对于一个森林，加上一个根节点，也就变成了树

## 2.树的存储
在前面我们讨论了二叉树的两种存储方式（顺序存储和链式存储），并介绍了元素在结构中的存放及遍历过程 
我们知道，**二叉树是一种有序树，结构中已明确表示了各结点之间的关系**；但对于**一般的无序树（多叉树）**，我们如何存储和表示其元素之间的结构关系呢？

下面介绍几种常见的树的存储方式及其实现
### 2.1双亲表示法

**实现方法**
- 定义结构数组用来存放书的结点，每个结点包含两个域：数据域和双亲域
- 数据域用来存放深数据本身；双亲域指示结点的双亲结点在数组中的位置

有这样的一个树结构：
![[Pasted image 20260113221054.png|450]]
则它的双亲表为：

| 数组下标 | data | parent |
| ---- | ---- | ------ |
| 0    | R    | -1     |
| 1    | A    | 0      |
| 2    | B    | 0      |
| 3    | C    | 0      |
| 4    | D    | 1      |
| 5    | E    | 1      |
| 6    | F    | 3      |
| 7    | G    | 6      |
| 8    | H    | 6      |
| 9    | K    | 6      |
**代码实现**
```C
typedef struct PTNode{
	TElemType data;
	int parent;
}PTNode;
typedef struct{
	typedef nodes[MAXSIZE];
	//两个整形结构,指示根结点位置和结点个数,相当于线性表中的Length
	int r,n;
}
```

**优缺点**
- 优点：通过 `parent` 字段，**查找双亲快速便捷**
- 缺点：**查找子结点需遍历所有结点**，效率低
总结：**找双亲容易，找孩子难**
### 2.2孩子链表表示法

**实现方法**
- 每个结点的所有孩子组织成一个**单链表**；
- 所有结点对应的孩子链表的**头指针数组**使用顺序结构存储

有这样一棵树：
![[Pasted image 20260113221309.png|375]]
则它的存储方式如下：
![[Pasted image 20260113222852.png]]
**代码实现**
孩子结点结构：
```C
typedef struct CTNode{
	int child;
	struct CTNode *next;
}*ChildPtr;
```
双亲结点结构：
```C
typedef struct{
	TElemType data;
	ChildPtr firstchild; //孩子链表头指针
}CTBox;
```
树结构：
```C
typedef struct{
	CTBox nodes[MAXSIZE];
	//结点树和根结点位置
	int n,r;
}CTree;
```

**优缺点**
- 与双亲表示法相反：**找孩子结点容易，找双亲结点难**
- 在孩子链表表示法的基础上，我们给每个双亲结点增加一个数据，来指示双亲结点的位置，解决了缺点，这种表示法也叫做：**带双亲的孩子链表**
### 2.3孩子兄弟表示法（二叉链表表示法）

**实现方法**
使用**二叉链表结构**，每个结点有两个指针域：
- firstchild：指向**第一个孩子**
- nextbro：指向**下一个兄弟**

有这样一棵树结构：
![[Pasted image 20260113221309.png|375]]
用孩子兄弟存储法表示后：
![[Pasted image 20260114231031.png|475]]

**代码实现**
```C
typedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextbro
}CSNode,*CSTree;
```

**优点**
- 将树的多叉结构用二叉链表的方式表示出来，这与二叉树的结构很相似，方便了树与二叉树的转换
# 二、二叉树
## 1.二叉树的逻辑结构
### 1.1二叉树的定义和相关概念
- 二叉树是一种特殊的树型结构，是n个结点的**有限集**
- 它可以是空集，也可以由一个根节点以及两个子树组成，两个子树称为根节点的**左子树和右子树**
- 每个结点最多有两个孩子，二叉树中**不存在度大于二的结点**
- **二叉树是有序树**，子树有左右次序之分，即使只有一颗子树也要进行区分，说明它是左子树还是右子树，不能颠倒
- 二叉树可以是空集，根结点下可以有空的左子树或者右子树

**满二叉树与完全二叉树**
- **满二叉树**：
	- 一棵深度为K且有$2^k-1$个结点的二叉树称为满二叉树
	- 除了叶子结点，其余结点的度均为二
	- 叶子结点全部在最底层

- **完全二叉树**：
	- 除了最后一层外，其他层的节点都填满，并且最后一层的节点都靠左排列，也就是**没有填满的满二叉树**
	- 叶子结点只能分布在层次最大的两层上面
	- 对任意结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1

- **满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树**

![[Pasted image 20260113213834.png]]
>需要特殊说明的是：在逻辑结构上，二叉树属于树的一种；但在数据结构的严格定义中，二叉树并不是“结点度最大为2”的普通树，它们之间存在本质的区别


**二叉树的一般性质**
1. 在二叉树的第$i$层上，最多有$2^{i-1}$个结点，最少有一个结点($i>=1$)
2. 深度为K的二叉树上最多有$2^k-1$个结点，最少有K个结点($k>=1$)
3. 对于任何一棵二叉树，如果叶子结点数为$n_0$，度为2的结点数为$n_2$，则有$n_0$=$n_2$$+1$

**完全二叉树的特有性质**
1. 具有n个结点的完全二叉树的深度为$\lfloor{log_2n}\rfloor$+1 
2. 对于完全二叉树的任一结点 i，有：
	- $i = 1$时，则结点 i是二叉树的根，无双亲；如果 i>1，则其双亲结点是$\lfloor{i/2}\rfloor$
	- 如果2i>n，则结点 i为叶子结点，无左孩子结点；否则其左孩子结点为2i
	- 如果2i + 1 > n，则结点 i无右孩子结点；否则其右孩子结点为2i+1

>$\lfloor{x}\rfloor$为向下取整
## 2.二叉树的顺序存储结构——顺序二叉树

### 2.1二叉树顺序存储的表示
- 二叉树的顺序存储结构，即顺序二叉树，是将二叉树的节点按照**满二叉树的结点编号规则**进行编号，再依次存放在一块**连续的内存空间**中

- 其底层实现方式与顺序表类似，都是使用数组进行顺序存储，在逻辑结构上是树结构，在存储结构上是一维数组

- 顺序二叉树的实现的关键在于：**结点在数组中的存放位置是按照特定规则映射**，而不是简单按先后顺序排列

**存储映射方式**
- 对于完全二叉树，我们可以直接按照元素的编号顺序存储即可；

- 但并不是所有的树都满足完全二叉树的结构，为了在取出元素时保持树原来的结构，我们就要进行特殊的存储方式

例如下面的一个非完全二叉树：
![[Pasted image 20260114014408.png|350]]

为了保存它的逻辑结构，我们在使用数组存储时，需要将满二叉树对应的位置空出，作为占位
存储空间示意如下：

| 数组a\[] | 对应结点 |
| ------ | ---- |
| a\[0]  | 1    |
| a\[1]  | 2    |
| a\[2]  | 3    |
| a\[3]  | 4    |
| a\[4]  | 5    |
| a\[5]  | null |
| a\[6]  | null |
| a\[7]  | null |
| a\[8]  | null |
| a\[9]  | 10   |
| a\[10] | 11   |


- 我们看到，使用顺序结构存储二叉树时，为了保留它的逻辑结构，空出了许多空闲空间；如果存入一个有k个结点的右单支树，需要长度$2^k-1$的一维数组，这对**空间的浪费**是很大的
- 为了尽可能地利用空间，我们存入的树结构要尽量饱满，也就是尽量满足**完全二叉树**的条件
### 2.2二叉树顺序存储的类型定义

```C
#def MAXSIZE 100
typedef int ElemType;
typedef ElemType SqBiTree[MAXSIZE];    //0号单元存储根节点
SqBiTree bt;
```

## 3.二叉树的链式存储结构——二叉链表
### 3.1二叉树链式存储的表示
- 前面我们说过，顺序结构在存储一般二叉树时，为了保留在逻辑结构上的映射，空闲了一些空间，这导致了对空间资源的使用效率很低；为了提高内存空间的利用率，我们引出了二叉树的链式存储，也叫**二叉链表**

- **二叉链表在逻辑结构和存储结构上都是树型的**

- 与链表结构类似，二叉链表基本的存储结构也是结点，每个结点内都有**数据域（data）和指针域（pointer）**；因为每个非叶子结点下面有两个孩子结点，对应的，我们也需要有左右两个指针域（**leftchild和rightchild**），来指引左右两个孩子结点

![[Pasted image 20260114235327.png|400]]

有了链式存储结构，我们就能很简单高效地实现元素的存储
![[Pasted image 20260114020644.png]]

- 我们可以看到，尽管存储元素的空间不是连续的，但是在存储结构上实现了树形结构，并且没有空间浪费    
- 对于有$n$个结点的二叉链表，一定有$2n$个指针域，除根节点外，每个结点最多被一个指针所指示，共有$n-1$个；则二叉链表中一共有**n+1**个空指针域      
### 3.2二叉树链式存储的类型定义
```C
typedef int TElemType
typedef struct BiNode{
	TElemType data;
	struct BiNode *Lchild,*Rchild;
}BiNode,*BiTree;
```


## 4.三叉链表
- 由于二叉链表的存储空间不连续，对于任意一个非根节点，在寻找它的孩子结点时很简单，但是寻找双亲节点时就要重新遍历整个链表，效率低下
- 为了解决这个问题，我们仿造双向链表，在每个结点中再添加一个指针域（**parent**）指向双亲结点，这就是**三叉链表**
![[Pasted image 20260114022604.png]]

**三叉链表的类型定义**
```C
typedef struct TriTNode{
	TElemType data;
	struct TriTNode *Lchild,*Rchild,*Parent;
}TriNode,*TriTree;
```


# 三、树与二叉树的转换
## 1.转换的引出
在实际应用中，**树结构每个结点的孩子个数不固定，操作起来相对复杂**；
而二叉树由于每个结点最多只有两个孩子，操作更为简洁高效；
因此，我们可以通过孩子兄弟表示法，**将树转换为二叉树**，借助二叉树的遍历和处理方式，简化对树结构的操作

为了实现这一点，我们通常采用如下思路：
- 先将树转换为结构等价的二叉树
- 在二叉树上进行相关操作
- 最后再将结果转换回原始的树结构

下面我们来介绍转换方法的实现
## 2.转换方法
- 由于树和二叉树都可以用**二叉链表作为存储结构**，则我们以二叉链表作为媒介来进行树与二叉树的转换
- 在前面，我们学了**树的孩子兄弟表示法**，在该表示法中：树中任意一个结点，左指针域存储孩子结点，右指针域存储兄弟结点；而二叉树的左右指针域存储的都是孩子结点；所以，对于在存空间中相同的存储结构，我们可以用两种不同的方式来表达

在存储空间中，有这样一个存储结构：            
![[Pasted image 20260114222429.png|150]]


相同的存储结构，能够使用不同的逻辑结构进行表示
![[Pasted image 20260114233052.png]]



- 对于任意的存储结构，都能转换成树或者二叉树结构，而且转换的**结构是确定的、唯一的**          
- 孩子兄弟表示法把“多叉树”的逻辑关系转化为“二叉结构”的存储形式，从而使树与二叉树之间能够互相转换，是二者之间转换的**关键媒介**
### 2.1将树转换成二叉树
1. 加线：在兄弟结点之间加一条线
2. 减线：对于每个结点，除了其**左孩子外**，去除其与其余孩子之间的关系
3. 旋转：以树的根结点为轴心，将树顺时针旋转45°

![[Pasted image 20260114235958.png]]
总结：**兄弟相连，留长子**


### 2.2将二叉树转换成树
1. 加线：若`p`结点是双亲结点的左孩子，则将`p`的右孩子、右孩子的右孩子……沿着分支找到所有的右孩子，都与`p`结点的双亲用线起来
2. 减线：减掉原二叉树中双亲与右孩子之间的连线
3. 调整：将结点按层次排列，形成树结构

![[Pasted image 20260115000507.png]]

总结：**左孩右右连双亲，去掉原来右孩线**


# 三、二叉树的遍历算法

## 1.遍历概念和遍历序列
在前几节，我们实现了二叉树的两种存储结构，现在我们已经可以将树的结构和内容完整地存入存储空间中；
但是，有存入就有读取，二叉树是一种特殊的结构，我们该怎么样对二叉树的元素进行读取呢，这就引出了**二叉树的遍历**
### 1.1遍历的相关概念

**遍历的定义**
- 在树的结构内，顺着某条搜索路径巡防二叉树中的结点，使得每个结点有且仅有被访问一次，这就是**遍历**
- 为了保持搜索路径的灵活性，在这里我们借助二叉链表的指针域；在下面，我们主要**使用二叉链来实现遍历**

>访问的含义很广，可以是对结点做各种增删查改的处理，但是访问不能破坏原来的数据结构

**遍历的目的**
- 我们对二叉树进行遍历操作后，会得到树中所有结点的一个**线性序列**
- 在这个线性排列的基础上，我们可以对树进行操作
- 遍历是对树操作的前提，是**二叉树一切运算的基础和核心**

**遍历的种类**
对于任意一个二叉树，都有三个部分：根节点（D）、左子树（L）、右子树（R），我们想遍历整个二叉树，就需要遍历这三个部分，我们规定遍历时遵守先左后右的顺序，则有三种遍历情况：

| 遍历顺序 | 名称      | 实际操作                      |
| ---- | ------- | ------------------------- |
| DLR  | 先（根）序遍历 | 先访问根节点，再先序遍历左子树，最后先序遍历右子树 |
| LDR  | 中（根）序遍历 | 先中序遍历左子树，再访问根节点，最后中序遍历右子树 |
| LRD  | 后（根）序遍历 | 先后续遍历左子树，再后序遍历右子树，最后访问根节点 |

由于二叉树本身就是递归式定义实现的，在遍历左、右子树时，我们可以**递归**地使用遍历，遍历完整棵子树

>递归：指的是**一个函数在其定义中调用自己**，直到满足某个**终止条件**为止；面对复杂问题时，把问题不断“自我拆解”，直到变成最小问题，再一层层返回答案

### 1.2遍历序列的推导
- 我们知道，二叉树中存储的结点一般不相同，用不同的遍历顺序得出的序列也不会相同，也就是唯一的
- 在一般情况下，我们可以根据多个不同的遍历序列来**逆向推导出树的结构**

*例如*：
对于一个二叉树，我们已知先序和中序序列，构造出相应的二叉树
先序序列：A B C D E F G H I J
中序序列：C D B F E A I H G J

*解决思路*：
1. 明确根节点，划分左右子树元素:
	- 根据先序序列，我们可以知道根节点为A结合中序序列，我们可以得知CDBFE为左子树元素、IHGJ为右子树元素

![[Pasted image 20260114023810.png|400]]

2. 找出左右子树的根结点和左右元素
	- 在第一步中，我们明确了左、右子树的元素
	- 由于先序序列中，根节点后为B，我们确定了左子树的根节点为B，其左元素为CD，右元素为FE
	- 同理，得出右子树的根节点为G，其左元素为IH，右元素为J
![[Pasted image 20260114024253.png|400]]

3. 依次递归推导左右序列
	- 现在，我们已经明确了左、右子树的元素，接着进行排列
	- 左子树的左元素先序排列为CD，中序排列为CD，我们就能确定C为B的左子节点，D为C的右子节点
	- 同理，我们也能推导出其余结点之间的关系
![[Pasted image 20260114024803.png|550]]

**遍历序列推导方法总结**

**前序遍历+中序遍历**
- 前序遍历的第一个节点是根节点
- 在中序遍历中找到该根节点，其左边是左子树，右边是右子树
- 递归构造左右子树

**中序遍历+后序遍历**
- 后序遍历的最后一个节点是根节点
- 在中序遍历中找到根节点，左边是左子树，右边是右子树
- 递归构建左右子树

**前序遍历+后序遍历**
- 注意，**前序遍历和后序遍历不能确定普通二叉树的结构**（除非是满二叉树）

## 2.二叉树遍历算法的实现
- 我们知道，树的结构本质上是亲子结点之间递归形成的；面对这种的复杂的结构，我们使用递归思想来遍历树的结构，使得算法的实现更加简单

- 遍历算法的递归实现，是**在二叉链表的存储结构上递归调用函数实现**的，二叉链的存储结构如下：
```C
typedef int TElemType
typedef struct BiNode{
	TElemType data;
	struct BiNode *Lchild,*Rchild;
}BiNode,*BiTree;
```

### 2.1先序遍历
- 若二叉树为空，则不进行操作；若二叉树不为空，先访问根节点，再前序遍历左子树，最后前序遍历右子树

```C
Status PreOrderTraverse(BiTree T){
	if(T == null) return OK;
	else{
		//在这里visit函数没有实际意义，我们代指对元素进行访问操作
		visit(T); 
		PreOrderTraverse(T->Lchild);
		PreOrderTraverse(T->Rchild);
	}
}  
```

### 2.2中序遍历
- 若二叉树为空，则不进行操作；若二叉树不为空，先中序遍历左子树，再访问根节点，最后中序遍历右子树

```C
Status InOrderTraverse(BiTree T){
	if(T == null) return Ok;
	else{
		InOrderTraverse(T->Lchild);
		visit(T);
		InOrderTraverse(T->Rchild);
	}
}
```

### 2.3后序遍历
- 若二叉树为空，则不进行操作；若二叉树不为空，先后序遍历左子树，再后序遍历右子树，最后访问根节点

```C
Status PostOrderTraverse(BiTree T){
	if(T == null) return Ok;
	else{
		PostOrderTraverse(T->Lchild);
		PostOrderTraverse(T->Rchild);
		visit(T);
	}
}
```

### 2.4递归遍历算法分析

- 在上面，我们可以看到三种算法的**访问的路径基本相同**（先左后右），唯一不同的就是**访问根节点的时机不同**

- 对于每个结点，在执行递归算法的过程中都会被''经过''**三次**；其中一次是作为根节点，遍历函数的''入口''，两次是在遍历完左右子树，返回上一层级的''出口''

- 对于某个结点：如果在第一次经过时进行访问，那就是先序遍历；在第二次经过时进行访问，那就是中序遍历；在第三次经过时进行访问，那就是后序遍历

- 时间效率：O(n)；空间效率：O(n)
### 2.5非递归遍历算法

- 我们在前面使用了递归算法来实现了遍历，虽然递归遍历简洁易懂，但是也存在一些潜在的缺点和局限性

- 递归算法本质上是使用**函数来调用栈**来实现的，在面对大型的二叉链表时，系统消耗的资源过多、性能低下，还有可能导致**栈溢出**；另外，由于算法内**栈是隐式的**，也不利于调试和控制

- 为了解决这些问题，我们将算法内的**栈调用显示**，手动维护栈；这也就引出了**遍历算法的非递归实现**

在这里，我们使用**中序遍历**来作为实现案例

**算法步骤**
- 初始化：创建一个空栈，存放遍历过程中遇到的结点；设一个指针 `p` 指向根节点
- 开始遍历，当p不为空，或栈不为空时，重复以下操作：
	 1. **沿左子树方向遍历**
		- 若p不为空，则将p压入栈中。
		- 然后令 `p = p->lchild`，即继续沿左子树方向遍历，直到最左端。
	2. **回退并访问节点**
		- 当p为空时，说明已到达某子树的最左端
		- 此时从栈顶弹出一个结点，将其设为p
		- 访问该结点（例如输出 `p->data`）
	3. **转向右子树**：
		- 访问当前结点后，将p移动到该结点的右孩子，即`p = p->rchild`
	     - 然后继续下一轮循环
- 结束条件：当`p == NULL`且栈为空时，表示整棵树的中序遍历已完成，算法结束

**算法演示**
假设有这样的一颗二叉树：
![[Pasted image 20260114233403.png|250]]
栈的操作：A压栈 ->B压栈 ->D压栈 ->B弹栈 ->E入栈 ->E弹栈 ->A弹栈 ->C压栈 ->C弹栈

最终中序遍历的输出结果是：D B E A C

**代码实现**
```C
void InOrderTraverse(BiTree T) {
    SqStack stack;
    InitStack(&stack);
    BiTree p = T;
		
    while (p || !IsEmpty(&stack)) {
        // 向左走，把路径上的每个节点压入栈
        while (p) {
            Push(&stack, p);
            p = p->Lchild;
        }
        // 左子树遍历结束，开始弹栈访问
        Pop(&stack, &p);
        printf("%c ", p->data);  // 访问当前节点
        // 转向右子树
        p = p->Rchild;
    }
    DestroyStack(&stack);
}
```
### 2.6二叉树的层次遍历

- 我们知道，二叉树结点之间的关系不仅有亲子关系，还有兄弟关系；拥有兄弟关系或者堂兄弟关系的结点，它们在树结构中属于同一个层次
- 我们可以利用二叉树的层次关系来实现二叉树的遍历，也就是**层次遍历**
- 对于一棵二叉树，从根节点开始，按从上到下、从左到右的顺序来访问每一个结点，每个结点仅仅被访问一次

>从逻辑结构上来讲，之前的遍历算法是从树的深度方向来进行遍历，而层次遍历是从树的广度方向来进行遍历，这也就决定了层次遍历算法的实现与众不同

**算法设计思路**
- 层次遍历的核心思路是**从上到下、从左到右、逐层访问**；也就是说，**谁先被访问，谁的孩子结点就先被等待访问**，这与**队列**的功能十分吻合，我们使用队列来实现层次遍历
- 队列的结构定义如下：
```C
#define MAXSIZE 100
typedef struct{
	BiTree data[MAXSIZE];
	int front,rear;
}Squeue;
```

**算法步骤**
- 初始化：初始化一个队列，来存放结点

- 开始遍历：
	- 将根结点入队
	- 队列不为空时循环执行：将第一个结点`p`出队，访问它
		- 若结点有左孩子结点，将左孩子结点入队
		- 若结点有右孩子结点，将右孩子结点入队

- 结束条件：队列为空时，说明树遍历完成，算法结束

**算法演示**
有如下的一棵二叉树：
![[Pasted image 20260115000808.png|400]]

对队列的操作：A入队 ->A出队 ， B、C入队 ->B出队 ，D、E入队 ->C出队，F、G入队 ->D、E 、F、G出队

最终读取的顺序为：A B C D E F G

**代码实现**
```C
void LevelOrder(BiTree T){
	if(T == null) return;
	BiNode *p;
	Squeue Q;
	InitQueue(&Q);
	//根节点入队
	EnQueue(&Q,T);
	//循环遍历结点，直到队列为空时结束
	while(!QueueEmpty(Q)){
		DeQueue(&Q,&p);
		visit(p);
		//左右孩子结点入队
		if(p->Lchild != null) EnQueue(&Q,p->Lchild);
		if(p->Rchild != null) EnQueue(&Q,p->Rchild);
	}
}
```
# 四、遍历算法的应用
## 1.二叉树的建立
- 我们知道，通过遍历序列（如先序+中序，中序+后序等），可以获取二叉树的结构
- 反过来，若我们拥有带有结构信息的遍历序列（如先序+占位符），则可以还原并建立出完整的二叉树

**算法思路**
- 单独的遍历序列并不能唯一确定一棵树结构，因此我们需要**引入额外的结构信息**
- 就像顺序二叉树存储中会**预留空位置**一样，我们在遍历序列中加入占位符（如 `#`）来表示空结点，从而使树结构信息完整
- 本例中使用**先序遍历序列**为例构建二叉树，`#` 表示对应位置的子树为空

**算法步骤**
1. 初始条件
	- 从输入中读取一串先序遍历序列（包含 `#` 表示空节点）。
	- 传入指向根节点的指针 `*T`

2. 执行过程（递归建树）
	1. 读取一个字符ch
	2. 判断 ch：
	    - 若 `ch == '#'`，说明当前子树为空，将 `*T = NULL`，返回上一层递归
	    - 否则（ch为有效节点数据），分配新节点空间，创建当前节点，将ch赋值给当前节点的data域，递归调用建树函数，创建当前节点的左右子树

3. 结束条件
	- 输入字符序列全部处理完毕
	- 树结构建立完成，`*T` 指向整棵二叉树的根节点

**代码实现**
```C
//建立二叉树
Status CreateBiTree(BiTree *T){
	//输入序列(序列中的空结点使用#占位)
	char ch;
	scanf(" %c",&ch);
	if(ch == '#'){
		*T = null;
	}else{
		*T = (BiTNode *)malloc(sizeof(BiTNode));
		if(!T) return ERROR;
		//生成根节点
		(*T)->data = ch;
		//构造左右子树
		CreateBiTree(&(*T)->Lchild);
		CreateBiTree(&(*T)->Rchild);
	}
	return OK;
}
```
## 2.二叉树的复制
- 二叉树的建立是在已知二叉树序列的前提下实现的，根据序列信息创建一棵新树
- 在已有现成树结构的情况下，我们可以将一棵二叉树的数据与结构完全复制到新的空间中，复制后的新树具有与原树完全相同的数据与结构，但在**内存中它们是不同的两棵树**

**算法思路**
- 我们通过递归的方式遍历原树的每个节点，并逐个创建新节点
- 复制的过程中，确保新树与原树相同的结构和数据，但每个节点在内存中的位置不同
- 我们采用**先序遍历**的方式进行树的复制，因为先序遍历可以确保我们先访问根节点，再访问左子树和右子树

**算法步骤**
1. 初始条件：输入一棵已存在的二叉树根节点 `T`，以及指向新树根节点的指针 `*newTree`

2. 执行过程：
    1. 若当前结点 `T == NULL`，说明已递归到空子树：
        - 将新树对应结点 `*newTree` 设置为 `NULL`
        - 返回上一层递归
    2. 若当前结点 `T != NULL`，则递归地执行以下操作：
        - **先处理当前节点**：
            - 为新树创建一个新节点，并分配内存
            - 将当前节点的 `data` 赋值给新节点
        - **再访问左子树**：递归调用复制函数，将原树左子树复制给新树的左子树
        - **再访问右子树**：递归调用复制函数，将原树右子树复制给新树的右子树
        - 每完成一次子树复制后，递归回退到双亲节点，继续另一个子树的复制

3. 结束条件：原树所有结点均被访问并复制，新树构建完成，且结构与数据完全一致但内存独立

**代码实现**
```C
// 复制二叉树
Status CopyBiTree(BiTree T, BiTree *newTree) {
    // 如果原树为空，直接返回
    if (T == NULL) {
        *newTree = NULL;
    } else {
        // 创建新节点
        *newTree = (BiTNode *)malloc(sizeof(BiTNode));
        if (!(*newTree)) return ERROR; // 内存分配失败
        // 复制当前节点的数据
        (*newTree)->data = T->data;
        // 递归复制左子树和右子树
        CopyBiTree(T->Lchild, &(*newTree)->Lchild);
        CopyBiTree(T->Rchild, &(*newTree)->Rchild);
    }
    return OK;
}
```
## 3.二叉树深度计算
- 二叉树的深度是指从根节点到叶子节点所经历的**最长路径的节点数**
- 我们可以通过**递归遍历整棵树**，依次比较左右子树的深度，最终得到整棵树的最大深度

**算法思路**
- 从根节点开始，分别计算左子树和右子树的深度
- 每次递归返回该子树的最大深度，即当前节点的深度应为其左右子树最大深度加一（即包含当前节点本身）
- 我们采用**后序遍历**（即左->右->根）的方式处理更适合这种“自底向上”的计算

**算法步骤**
1. 初始条件：输入一棵已存在的二叉树根节点 `T`

2. 执行过程（后序遍历）：
    1. 若当前结点 `T == NULL`，说明已递归到空子树，返回深度0
    2. 若当前结点 `T != NULL`，对左右子树进行递归，统计左右子树的深度，并返回深度较大的值
3. 结束条件：根节点深度计算完成，返回整棵树的最大深度

**代码实现**
```C
// 计算二叉树的最大深度
int TreeDepth(BiTree T) {
    if (T == NULL) {
        return 0; // 空树深度为 0
    } else {
        // 1. 先递归访问左子树
        int leftDepth = TreeDepth(T->Lchild);
        // 2. 再递归访问右子树
        int rightDepth = TreeDepth(T->Rchild);
        // 3. 最后合并左右子树的结果，返回当前结点深度
        return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
    }
}
```
## 4.二叉树的结点数统计
- 在遍历整棵树的过程中，我们可以统计整棵二叉树中**结点的总数**
- 利用递归的方式，从根节点出发，逐层向下统计左右子树结点数量，再加上当前节点，最终得到整棵树的结点数

**算法思路**
- 我们从上到下遍历树结构，但是从下向上来对结点进行计数，从左右子树**向上逐层回传结点数**
- 每个非空树的结点总数 = 左子树结点数 + 右子树结点数 + 1（根节点本身）
- 每个空结点会返回0，不影响统计结果
- 递归结束后，根节点返回的是整棵树的结点总数

**算法步骤**
1. 初始条件：传入指向二叉树根节点的指针 `T`
2. 执行过程（后序遍历）：
    1. 若当前节点 `T == NULL`：说明该子树为空，返回结点数为0，并回退到上一层递归
    2. 若当前节点 `T != NULL`：对左右子树递归，返回左右子树的结点数和根节点总数
3. 结束条件：当根节点的递归结束时，即可获得整棵树的结点总数

**代码实现**
```C
// 统计二叉树中节点总数
int CountNodes(BiTree T) {
    if (T == NULL) {
        return 0; // 空树返回0
    } else {
	    // 当前树总结点数
        return CountNodes(T->Lchild) + CountNodes(T->Rchild) + 1;       
    }
}
```
## 5.二叉树叶子节点统计
- 叶子节点是指左右子树均为空的结点，这是我们实现统计叶子结点算法的核心判断标准

**算法思路**
- 我们通过递归的方式，遍历二叉树的每一个节点。
- 判断当前节点是否为叶子节点（即**左右子树都为空**），若是则计数
- 否则继续递归遍历其左右子树，直到所有节点都被访问完毕
- 最终将所有叶子节点数加总返回

**算法步骤** 
1. 初始条件：传入一棵二叉树的根节点 `T`

2. 执行过程：
    1. 若当前结点 `T == NULL`，说明是空子树，返回0
    2. 若当前结点左右子树均为空，说明该节点是叶子节点，返回1
    3. 否则，递归统计左右子树中的叶子节点数，并将结果相加

3. 结束条件：所有节点访问完毕后，函数返回整棵树中叶子节点的总数

**代码实现**
```C
int LeafCount(BiTree T){
	//如果是空树，返回0
	if(T == null) return 0;
	//如果是叶子节点，返回1
	if(T -> Lchild == null && T-> Rchild == null){
		return 1;
	}else{
		//递归遍历该节点的左右子树
		return LeafCount(T->Lchild) + LeafCount(T-> Rchild);
	}
}
```

# 五、线索二叉树
我们知道，在使用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点地左右孩子结点；但是一般情况下，我们无法找到该结点在某种遍历序列中的前驱和后继结点

*那我们该怎么找到特定序列下某个结点的前驱和后继呢？*
- 将二叉树按照遍历顺序重新遍历寻找，但是较为浪费时间
- 再增设前驱和后继指针域，但是增加了空间负担
- **利用二叉链表中的空指针域**：将空的左孩子结点指针改为指向其前驱；空的右孩子结点指针改为指向其后继

>在前面我们说过，对于一个有n个结点的二叉链表，其中就有n+1个指针域为空，在这些空的指针域中，我们写上判断标志，作为指针方向的指引。

这种**改变了指向的指针**称为**线索**，而加上了线索的二叉树我们就称为**线索二叉树**，对二叉树按照某种遍历次序使其变为线索二叉树的过程叫做**线索化**


## 1.线索二叉树存储结构的表示

- 在二叉链表中，每个结点有两个指针域：Lchild 和 Rchild。在不影响树结构的前提下，将原本空的指针域存储该结点在某种遍历顺序下的**前驱或后继节点地址**，这种指针称为“线索”
- 对应地，节点会增加两个**线索标志位**，用于区分当前指针是“子树”还是“线索”，其对应规则为：
    $$
\begin{aligned}
\mathrm{LTag} &= 
\begin{cases}
0 & \text{lchild 域指示结点的左孩子} \\
1 & \text{lchild 域指示结点的前驱}
\end{cases} \\[1.5em]
\mathrm{RTag} &= 
\begin{cases}
0 & \text{rchild 域指示结点的右孩子} \\
1 & \text{rchild 域指示结点的后继}
\end{cases}
\end{aligned}
$$

线索化后的结点结构：
![[Pasted image 20260114221112.png|450]]

- 在这里我们看到，与之前相比，在结点中新增了两个`int`值；`int`类型的值，每个占位4字节。虽然也有额外的内存开销，但是我们让空指针也承担实际作用，**不需要新开辟空间**来存储每个结点前驱、后继结点的信息

## 2.线索二叉树的类型定义
```C
// 定义线索二叉树节点结构
typedef struct BiThrNode {
    char data;
    struct BiThrNode *Lchild, *Rchild;
    // Ltag==0表示Lchild是左孩子，1表示线索；Rtag同理
    int Ltag, Rtag;
} BiThrNode, *BiThrTree;
```
## 3.二叉树的线索化
对于二叉链表，三种不同的遍历方式，就能遍历出三种不同的序列；在这里我们讨论在**中序遍历**下，将普通二叉树的线索化

**算法步骤**
- 遍历顺序：左子树 → 当前节点 → 右子树
- 若当前节点的左孩子为空，将其`Lchild`指向中序前驱节点
- 若前驱节点的右孩子为空，将其`Rchild`指向当前节点（即后继）
- 用一个`pre`指针始终记录当前节点的前驱
- 对于叶子节点，一侧指针指向前驱、一侧指针指向根节点；增强树的循环结构，方便遍历

**代码实现**
```C
BiThrNode *pre = NULL;
void InThreading(BiThrNode *T, BiThrNode *root) {
    if (T) {
        InThreading(T->Lchild, root);
        if (!T->Lchild) {
            T->Ltag = 1;
            T->Lchild = pre ? pre : root; // 若没有前驱，指向根节点
        }
        if (pre && !pre->Rchild) {
            pre->Rtag = 1;
            pre->Rchild = T;
        }
        // 如果当前是叶子节点，则将空指针指向根节点
        if (!T->Lchild && !T->Rchild) {
            if (T->Ltag == 0) {
                T->Ltag = 1;
                T->Lchild = root;
            }
            if (T->Rtag == 0) {
                T->Rtag = 1;
                T->Rchild = root;
            }
        }
        pre = T;
        InThreading(T->Rchild, root);
    }
}
```

# 六、森林

## 1.森林的概念
**森林（Forest）是指由若干棵互不相交的树组成**的集合；通俗来说，森林就是多棵树放在一起的结构

*我们为什么要研究森林呢？*
- **扩展树结构的表达能力**  
    有些复杂的数据层级或组织关系不是一棵树能完全表达的，比如有多个根节点的情况，这时森林就比树更灵活
- **与其他数据结构的转换关系**  
    森林与二叉树可以相互转换（尤其是“孩子兄弟表示法”）；通过转换，很多关于森林的问题都可以用处理二叉树的方法来解决

## 2.森林的转换
- 在数据结构中，**森林（Forest）是由多棵互不相交的树组成的集合**；相较于单棵树，森林的结构更复杂，直接操作较为不便           
- 为了简化处理，我们通常**将森林转换为一棵二叉树**，借助二叉树的统一结构和遍历方法进行处理  
- 这一转换不仅便于算法实现（如遍历、查找），还加深了对树结构层次关系的理解
- 因此，掌握森林与二叉树之间的相互转换，是理解和操作树形结构的重要基础

下面我们介绍具体的转换规则和步骤


### 2.1森林转二叉树
**转换步骤：**
1. 将森林中的每棵树按“孩子兄弟表示法”转换为对应的二叉树
2. 将所有树的**根节点依次用右指针相连**
3. 以第一棵树的根作为二叉树的根结点，整体顺时针旋转，构成一棵完整的二叉树

总结：**树变二叉，根相连**

### 2.2二叉树转森林
**转换步骤：**
1. 将二叉树中根结点与其右孩子，以及右孩子的右孩子……这些**右指针连接**全部**断开**，使每棵树成为一个孤立的二叉树
2. 对每个孤立的二叉树，按“孩子兄弟表示法”逆转，**还原为普通树结构**
3. 多棵树组合构成森林

总结：**去掉全部右孩线，孤立二叉再还原**



# 七、树和森林的遍历
## 1.树的遍历
在前面的章节中，我们探讨过二叉树的四种遍历方式：前序遍历、中序遍历、后序遍历和层次遍历；
对于树结构，由于结点之间没有次序，就只有三种遍历顺序方式：先根遍历、后根遍历、层次遍历


- 先根遍历：若树不为空，则先访问根结点，然后依次先根遍历各子树
- 后根遍历：若树不为空，则先依次后根遍历各棵子树，然后访问根结点
- 层次遍历：若树不为空，则自上而下、从左向右访问树中每个结点

有这样的一棵树：
![[Pasted image 20260115001048.png|250]]
按照三种遍历的结果为：
- 先根遍历：ABCDE
- 后根遍历：BDCEA
- 层次遍历：ABCED
## 2.森林的遍历
- 森林是多棵不相干的树的集合，对于森林而言，没有所谓的根结点；为了对森林进行遍历的操作，我们要将森林分为三个部分：
	1. 森林中第一棵树的根节点
	2. 森林中第一棵树的子树构成的森林
	3. 森林中其他树构成的森林
- 将森林视为**第一棵树 + 其余森林**，以此类推递归处理，对于森林有两种遍历：先序遍历、中序遍历

*我们无法确定森林最后一棵树的位置，所以没有后序遍历的方式*

**先序遍历**
若森林不为空：
1. 访问森林中的第一棵树的根节点
2. 先序遍历森林中第一棵树的子树森林
3. 先序遍历森林中其余树构成的森林
 
**中序遍历**
若森林不为空：
1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中的第一棵树的根节点
3. 中遍历森林中其余树构成的森林



有这样一个森林：
![[Pasted image 20260115001616.png|500]]
不同的遍历结果为：
先序遍历：ABCDEFGHIJ
中序序遍历：BCDAFEHJIG

# 八、二叉树的应用——哈夫曼树和哈夫曼编码
## 1.哈夫曼树
### 1.1哈夫曼树的引出
现在有一个需求：将学生的成绩从百分制转换为ABCDE五个档次的成绩
- 用C语言实现很简单：
```C
if(score < 60)
	grade = 'E';
else if(score < 70)
	grade = 'D';
else if(score < 80)
	grade = 'C';
else if(score < 90)
	grade = 'B';
else
	grade = 'A';
```
- 用树结构表示则为：
![[Pasted image 20250528220356.png|175]]
这种用来进行判断并分类的树，我们称之为**判断树**

但是，我们知道，成绩分布并不是均匀的，大部分学生的成绩都分布在70-90这个区间上，每次都要对这部分学生进行大量的判断，学生的数据量过于巨大时，程序的效率就比较低下

- 为了优化结构，减少判断次数，我们将判断树的起始点更改，如图：
![[Pasted image 20250528220023.png|400]]
显然，两种树的判别的效率是不一样的，经过更改后的判断树效率更高

*那怎么构建树的结构，使之效率最大化呢？*

这也就是我们接下来要研究的东西——**最优二叉树**，也就是**哈夫曼树**
### 1.2哈夫曼树的基本概念
下面简单介绍哈夫曼树的几个概念
- 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径

- 结点的路径长度：两结点路径上的分支数

- 树的路径长度：从树的根结点到每一个结点的路径长度之和，记作TL；结点数目相同的二叉树中，**完全二叉树是路径长度最短的二叉树**
- 权：将树中结点赋值给一个有某种含义的数值，则称这个数值为该结点的权
- 结点的带权路径长度：**从根结点**到该结点之间的路径长度与该结点的权的乘积
- **树的带权路径长度**：树中**所有叶子结点的带权路径长度之和**，记作：WPL（weight path length）。WPL计算公式：$WPL = \sum^n_{k=1}W_kL_k$，我们在讨论`WPL`时，范围仅限于**度相等的树中**

**哈夫曼树的几个特点**

- 满二叉树不一定是哈夫曼树
- 哈夫曼树中权重越大的叶子节点离根结点越近
- 具有相同的带权结点的哈夫曼树并不唯一
- 包含`n`个叶子结点的哈夫曼树中共有2n-1个结点
- 哈夫曼树的结点的度为0或2，没有度为1的结点

### 1.3哈夫曼树的构造

已知一组权值{W1, W2, ..., Wn}的结点，现在构造一棵**带权路径长度最小**的二叉树——即哈夫曼树

**算法思路**
- 权重越大的结点应离根越近，以减少路径乘积
- 权重越小的结点则应离根越远
- 因此**从权值最小的结点开始组合构建整棵树**，也叫做**贪心策略**

>贪心策略（Greedy Strategy）是一种算法设计思想，其核心是在每一步决策时，都选择当前看来最优的局部解，希望通过一系列局部最优选择最终达到全局最优解——简单来说就是从局部最优推向全局最优

**算法步骤**
1. 我们使用{W1, W2, ..., Wn}构成含n棵二叉树的森林F={T1,T2,……Tn}，其中`Ti`是只有一个带权重为$W_i$的根结点
2. 在F中选取两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点权重值之和
3. 在F中删除这两棵树，同时将新得到的二叉树加入森林中
4. 重复执行2、3两步，一直到F中只剩下一棵树，这棵树就是哈夫曼


**算法演示**
问题：有4个结点A、B、C、D，权值分别是7、5、2、4，构造哈夫曼树

解决步骤：
1. 初始时，构造4棵只有根结点的二叉树组成森林
![[Pasted image 20250715083239.png|400]]
2. 选择根结点权重值最小的两棵树，组成新的二叉树，它们的双亲结点权重值等于子树权重值的和
![[Pasted image 20250715083452.png|200]]
3. 删除掉原先的两个二叉树，将新树添加入森林
![[Pasted image 20250715083404.png|400]]
4. 我们重复执行2、3两步，最终就能构造出哈夫曼树
![[Pasted image 20250715083713.png|300]]

**算法要点**
1. 包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点
2. 哈夫曼树中共有n+(n-1)=2n-1个结点，所有结点的度均不为1

**代码实现**
哈夫曼树，也是二叉树，也就也能采用顺序存储和链式存储两种结构
出于简便，我们使用顺序存储结构——**一维结构数组**来实现算法

- 结点的类型定义
```C
typedef struct {
	int weight;  //结点的权重
	int parent,lchild,rchild; //孩子、双亲结点的信息
}HTNode,*HuffmanTree;
```

- 实现选择权重最小两个结点的功能
```C
void Select(HuffmanTree HT, int n, int *s1, int *s2) {
	//分别记录当前最小和次小的两个权值
    int min1 = 0, min2 = 0;
    //将下标初始化
    *s1 = *s2 = 0;
	//HT[1] ~ HT[n] 是当前未合并的叶子或内部结点
    for (int i = 1; i <= n; i++) {
	    //结点的父节点为零，则表示该结点未参与合并
        if (HT[i].parent == 0) {
	        //如果当前遍历结点的权重更小，就将原本最小变成次小结点并更新最小结点
            if (HT[i].weight < min1) {
                min2 = min1; 
                *s2 = *s1;
                min1 = HT[i].weight; 
                *s1 = i;
            //若当前权重仅次于最小，就只更新次小    
            } else if (HT[i].weight < min2) {
                min2 = HT[i].weight;
                *s2 = i;
            }
        }
    }
}
```

- 接下来开始构造哈夫曼树
```C
void CreateHuffmanTree(HuffmanTree HT, int w[], int n) {
    int m = 2 * n - 1;
	//初始化哈夫曼数组
    for (int i = 1; i <= n; ++i) {
	    // w 数组从下标0开始
        HT[i].weight = w[i - 1]; 
        HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }
    for (int i = n + 1; i <= m; ++i) {
        HT[i].weight = HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }

    for (int i = n + 1; i <= m; ++i) {
        int s1, s2;
        //调用Select函数
        Select(HT, i - 1, &s1, &s2);
        HT[s1].parent = HT[s2].parent = i;
        HT[i].lchild = s1
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

- 调用函数
```C
int main() {
	//权值数组
    int w[] = {5, 9, 12, 13, 16, 45};
    //权值的个数 
    int n = sizeof(w) / sizeof(w[0]);
    //哈夫曼树的结点树为2n-1
    int m = 2 * n - 1;
	//创建大小为2n的哈夫曼数组，其中第0号结点不使用
    HuffmanTree HT = (HTNode *)malloc((m + 1) * sizeof(HTNode));  
    if (!HT) {
        printf("内存分配失败\n");
        return -1;
    }

    CreateHuffmanTree(HT, w, n);
   
	//打印哈夫曼树
	printf("序号\t权重\t父\t左\t右\n");
    for (int i = 1; i <= m; ++i) {
        printf("%d\t%d\t%d\t%d\t%d\n", i, HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);
    }
    
    free(HT);
    return 0;
}
```

## 2.哈夫曼编码
### 2.1哈夫曼编码的引出
在远程通讯中，要将待传字符串转换成二进制的字符比如：
A——00；B——01；C——10；D——11。
ABACCDA——*00*01*00*10*10*11*00*

但是，并不是所有的字符串使用频率都一样，我们可以用**短的编码表示高频字符**，**长的编码表示低频字符**，从而减少整体编码长度。
转换后：A——0；B——00；C——1；D——01
ABACCDA——**0**00**0**1**1**01**0**

这样做显著减少了码数，但是有一个问题：对于*0000*这串代码，出现了歧义，有三种理解：AAAA、ABA、BB。我们称这种情况叫做**重码**

为了重码，我们就要规定：**任一字符的编码都不是其他字符的编码的前缀**，这种编码叫做**前缀编码**，总长最短的前缀编码就是**哈夫曼编码**

*那怎么求得哈夫曼编码呢？*
### 2.2哈夫曼编码的构造
**算法思想**
1. 统计字符集中每个字符在电文中出现的平均概率，概率越大，编码越短。

2. 利用哈夫曼树的特点：权越大的叶子结点离根越近；将每个字符的概率作为权值，构造哈夫曼树。

3. 在哈夫曼树的每个分支上表0或者1：结点的左分支标0；右分支标1。

4. 把从根结点的每个叶子结点的路径上的标号连接起来，就能作为该叶子结点代表的字符的编码。

**算法演示**
现有字符集D={C,A,S,T,M}，及其出现出现频率W={2,4,2,3,3}，求出各字符的哈夫曼编码

解决步骤：
1. 按照哈夫曼算法，我们根据权重构造哈夫曼树，如下图：
![[Pasted image 20250421212041.png|L|500]]
2. 按照左右分支，我们在分支上标记0和1
![[Pasted image 20250421211947.png|L|500]]
3. 按照分支上的数字，我们得出每个字符的编码：
	T——00；M——01；A——10；C——110；S——111

**关于算法的几个问题**
1. *为什么哈夫曼编码能够保证是前缀编码？*
前缀编码的定义：**任一字符的编码都不是其他字符的编码的前缀**；在哈夫曼树中，没有一个叶子结点是另一个叶子结点的祖先，所以每个叶子结点的编码也就不可能是其他叶子结点编码的前缀
2. *为什么哈夫曼编码能够保证字符编码总长最短？*	
我们设计哈夫曼树的依据，就是WPL最小；表现在前缀编码中，就是字符编码的总长，即$\sum编码使用频率*编码长度$最小，以哈夫曼树为基础构造的哈夫曼编码完美的匹配了这一点

**算法步骤**
在算法的实际实现中，为了效率的高效，我们采用从叶子结点依次向上遍历的方法
- 使用一个临时数组cd存储哈夫曼编码，因为我们从树结构的底层出发，所以编码数组也从末尾逆序存储

- 对于每个叶子结点，从它开始向上遍历：
	- 如果当前结点是其父结点的左孩子，cd数组末尾存储0
	- 如果是右孩子，则存储1
	- 更新当前结点，继续向上遍历，直到根结点

- 将临时数组cd中的编码正序存储在保存所有叶子结点的编码数组HC中

**代码实现**
- 首先对哈夫曼树的结点结构进行定义
```C
typedef struct {
	int weight;  //结点的权重
	int parent,lchild,rchild; //孩子、双亲结点的信息
}HTNode,*Huffman Tree;
```

- 构造哈夫曼树
```C
//选择函数
void Select(HuffmanTree HT, int n, int *s1, int *s2) {
    int min1 = 0, min2 = 0;
    *s1 = *s2 = 0;
    for (int i = 1; i <= n; i++) {
        if (HT[i].parent == 0) {
            if (HT[i].weight < min1) {
                min2 = min1; 
                *s2 = *s1;
                min1 = HT[i].weight; 
                *s1 = i;   
            } else if (HT[i].weight < min2) {
                min2 = HT[i].weight;
                *s2 = i;
            }
        }
    }
//构造函数
void CreateHuffmanTree(HuffmanTree HT, int w[], int n) {
    int m = 2 * n - 1;
    for (int i = 1; i <= n; ++i) {
        HT[i].weight = w[i - 1]; 
        HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }
    for (int i = n + 1; i <= m; ++i) {
        HT[i].weight = HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }

    for (int i = n + 1; i <= m; ++i) {
        int s1, s2;
        Select(HT, i - 1, &s1, &s2);
        HT[s1].parent = HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

- 给每个叶子结点创建哈夫曼编码
```C
void HuffmanCode(HuffmanTree HT, int n) {
	//定义并分配一个二维字符数组HC，HC[1..n]用于存储 n 个编码（0号元素不用）
    char **HC = (char **)malloc((n + 1) * sizeof(char *));
    //定义一个临时字符数组cd用于构造当前节点的哈夫曼编码
    char *cd = (char *)malloc(n * sizeof(char));
    //在临时存储数组末尾添加终止符'/0'，作为结束标志
    cd[n - 1] = '\0';
	//对所有叶子结点进行遍历，逐个生成哈夫曼编码
    for (int i = 1; i <= n; ++i) {
	    //我们从数组的末尾开始填入编码的每一位
        int start = n - 1;
        //c：当前结点；f当前结点的父结点
        int c = i, f = HT[i].parent;
		//我们从叶子结点向上追溯，一直到根结点，也就是父节点不存在
        while (f != 0) {
		        //如果当前节点是父节点的左孩子，编码为0，否则为1
            cd[--start] = (HT[f].lchild == c) ? '0' : '1';
            //将结点上移一层，继续向上追溯
            c = f;
            f = HT[f].parent;
        }
		//为HC[i]分配一段新内存，长度为编码长度 + 1（包括 `\0`）
        HC[i] = (char *)malloc((n - start + 1) * sizeof(char));
        strcpy(HC[i], &cd[start]);
    }

    free(cd);

    // 打印编码
    printf("\n哈夫曼编码如下：\n");
    for (int i = 1; i <= n; ++i) {
        printf("权重 %d: 编码 = %s\n", HT[i].weight, HC[i]);
        free(HC[i]);
    }
    free(HC);
}
```
### 2.3哈夫曼编码的解码

我们已知字符频度表W((u,5),(v,6),(w,2),(x,9),(y,7))，现在我们收到了一串哈夫曼编码：*11000110111101011000111*，求出原码报文

**解决思路**
- 解码的关键在于确定字符与编码之间的对于关系，也就是构造哈夫曼编码
- 确定了编码后，由于前缀编码的特性，我们就能很轻松地确定原码

**解决过程**
1. 根据频度表构建哈夫曼树，确定哈夫曼编码
![[Pasted image 20250422145932.png|L|525]]
2. 根据上图，我们确定了哈夫曼编码：
	Y——00；X——01；V——10；W——110；U——111


3. 我们根据哈夫曼编码就能确定原码了，原码为：WYWUVVWYU