---
time: 2025-03-02
author: Fang
tags:
date: 2025-03-10
---
在本节中，我们主要讨论线性结构的几种数据结构，线性结构的特点是：在数据元素非空的有限集中：
1. 存在唯一的一个被称做“第一个＂的数据元素； 
2. 存在唯一的一个被称做“最后 一个＂的数据元素； 
3. 除第一个之外，集合中的每个数据元素均只有一个前驱； 
4. 除最后一个之外，集合中每个数据元素均只有一个后继。

在线性结构中，**线性表**作为最基础、最核心的数据结构之一，是学习数据结构与算法的起点；它以其简单而清晰的结构，在各种应用场景中扮演着关键角色，从数组、链表到后续更复杂的数据结构如栈、队列、哈希表等，几乎都离不开线性表的概念和实现基础

下面，我们从线性表出发，敲开数据结构与算法的大门

# 一、线性表的逻辑结构
## 1.线性表的定义和相关概念

- 线性表是由n（n≥0）个**类型相同的数据元素组成的有限序列**；
- 线性表常用$L=(a_1,a_2......a_{i-1},a_{i},a_{i+1}.....a_n)$来表示，其中：L为表名，$a_i$表示该线性表的第i个数据元素；
- 在逻辑关系上，除了表头元素和表尾元素，每个数据元素都有对应的**直接前驱**和**直接后继**；
![[Pasted image 20250705231010.png]]
- 线性表中数据元素的个数被称为**线性表的长度**，当n=0时，称为**空线性表**；
- 在稍复杂的线性表中，**一个数据元素可以由若干个数据项(item)组成**；在这种情况 下，常把数据元素称为**记录**(record),含有大量记录的线性表又称**文件**(file)
# 二、线性表的顺序存储结构——顺序表
## 1.线性表顺序存储的表示
线性表的顺序表示指的是**用一组地址连续的存储单元依次存储线性表的数据元素**

假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第i+1个数据元素的存储位置$LOC(a_{i+1})$和第1个数据元素的存储位置$LOC(a_i)$之间满足下列关系：
$$LOC(a_{i+1})=LOC(a_i)+l$$
一般来说，线性表的第i个数据元素$a_i$的存储位置为:
$$LOC(a_{i})=LOC(a_1)+(i-1)*l$$
这种存储结构的特点是：**将逻辑上相邻的数据元素，存储在物理上也相邻的存储单元中**，简而言之：**逻辑上相邻，物理上也相邻**；
由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可**随机存取**，所以线性表的顺序存储结构是一种随机存取的存储结构。

![[Pasted image 20250705233405.png|500]]
## 2.线性表的顺序存储的类型定义

为了实现顺序存储，数据元素必须满足以下条件：
- 地址连续
- 依次存放
- 可随机存取（支持下标）
- 类型相同
以上这些正是一维数组的特点，因此，我们可以使用一维数组作为基础，来表示顺序表

由于线性表的长度可变，我们需要**一个变量额外记录线性表的长度**

我们提前设定好线性表所占用的最大容量，在定义线性表时，就分配好内存空间，这种内存分配方式叫做**内存的静态分配**，如下：
```C
#define List_Init_Size 100                                //定义线性表最大容量
typedef int ElemType;
typedef struct {
    ElemType elem[List_Init_Size];                    //元素数组
    int length;                                                     // 记录线性表的长度
}SeqList,*PSeqList;
```

因为线性表所需最大存储空间随问题不同而不同，也可以使用**动态分配**的一维数组，如下：
```C
#define MAXSIZE 100
typedef int Elemtype;
typedef struct{
	ElemType *elem;
	int length;
}SeqList,*PSeqList;
```

在这里，`PSqList`是`SqList`的指针类型，以后我们采用动态分配的方式来创建线性表
## 3.线性表顺序存储的基本运算实现

**初始化线性表**
```c
int InitList_Sq(Seqlist *L) {
    L.elem = (ElemType*)malloc(MAXSIZE * sizeof(ElemType));
    if (!L.elem){
	    printf("内存分配失败");
	    return -1;
	}; // 内存分配失败
    L.length = 0; // 初始为空表
    return 1;
}
```

**销毁线性表**
```c
void DestroyList(Sqlist *L) {
    if (L->elem != NULL) {
        free(L->elem);       // 释放内存
        L->elem = NULL;      // 防止悬空指针
        L->length = 0;       // 同时也清空长度
    }
}
```

**清空线性表**
```c
void ClearList(Sqlist *L) {
    L->length = 0;
}
```

**获取线性表长度**
```c
int GetLength(Sqlist L) {
    return L.length;
}
```

**判断是否为空表**
```c
int IsEmpty(Sqlist L) {
    return L.length == 0 ? 1 : 0;        //如果是空表，就输出0，否则输出1
}
```

**获取元素值**
```c
int GetElem(Sqlist L, int i, ElemType *e) {
    if (i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1]; //使用解指针来给元素赋值
    return 1;
}
```

**查找元素位置**
```c
int LocateElem(Sqlist L, ElemType e) {
    for (int i = 0; i < L.length; i++) {
        if (L.elem[i] == e) return i + 1;
    }
    return 0; // 查找失败
}
```

**插入元素**
```c
Status ListInsert_Sq(Sqlist *L, int i, ElemType e) {
    if (i < 1 || i > L->length + 1) return -1;                               // 插入位置不合法
    if (L->length == MAXSIZE) return 0;                             // 存储空间已满
    // 从后往前移动元素
    for (int j = L->length - 1; j >= i - 1; j--) {
        L->elem[j + 1] = L->elem[j];
    }                                                                               
    L->elem[i - 1] = e;                                                          // 插入新元素
    L->length++;                                                                 // 更新表长
    return 1;
}
```

**删除元素**
```c
Status ListDelete_Sq(Sqlist *L, int i) {
    if (i < 1 || i > L->length) return -1;  // 删除位置不合法
    // 从删除位置后的元素前移
    for (int j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    // 更新表长
    L->length--;
    return 1;
}
```

### 算法效率分析
- 时间复杂度：查找，插入，删除算法的平均时间复杂度为O(n)
- 空间复杂度：因为没有占用辅助空间，顺序表算法操作的空间复杂度为S(n) = O(1) 
# 三、线性表的链式存储结构——链表
从上面的讨论中可见，线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任一元素，它的存储位置可用一个简单、 直观的公式来表示。然而，从另一方面来看，这个特点也铸成了这种存储结构的弱点：在插入或删除操作时，需移动大量元素。

本节我们将讨论线性表的另一种表示方法——**链式存储结构**，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优点。

## 1.线性表链式存储的表示
为了用链式结构表示线性表，我们定义了以下概念：

1. 结点：链表中的基本单位，包含数据域和指针域；数据域存储数据，指针域存储指向下一个结点的指针。
2. 链表：由多个结点通过指针相连组成的线性结构；每个结点通过指针指向下一个结点，形成链式结构，逻辑上相邻，但是**物理上不一定相邻**。

3. 头指针、头节点与首元结点：
    - 头指针：指向链表第一个结点的指针，整个链表的存取必须从头指针开始进行；
    - 头节点：链表的特殊结点，位于首元结点之前，头指针指向头节点；
    - 首元结点：链表中存储第一个元素的结点。
4. 链式表的空表表示：
    - 无头节点时，头指针为空表示空表；
    - 有头节点时，头节点的指针域为空表示空表。   
5. 使用头节点的好处：
	- 简化首元结点的处理：头节点的指针域指向首元结点，使得处理链表的第一个结点与其他结点一致； 
      - 统一空表与非空表的处理：头指针指向头节点，因此空表和非空表的处理方式一致。 
6. 头节点的数据域：头节点的数据域通常为空，但也可以存放附加信息（如链表长度）；此结点不计入链表的实际长度。

*以单链表为例，我们有如下的几个表*：
![[Pasted image 20250708220601.png]]

## 2.链式表的三种类型
- **单链表**：每个结点只有一个指针域，指向下一个结点；    
- **双链表**：每个结点有两个指针域，一个指向前驱结点，一个指向后继结点；
- **循环链表**：最后一个结点的指针指向头结点，形成循环。

下面来分别介绍这三个链式表，为了方便，我们均采用带有头结点的链式表

## 3.单链表的存储及基本运算的实现
### 3.1单链表存储结构的类型定义

**结点的结构**：
单链表的基本存储结构是结点，每个结点又包含两个部分：**数据域**和**指针域**
![[Pasted image 20250306162727.png|450]]

- **数据域 (data)**：存储元素数据，类型取决于元素的类型。
- **指针域 (next)**：存储下一个结点的地址，类型取决于链表中结点的类型，例如指向 `Lnode` 类型的指针。

**代码如下**：
```C
typedef struct Lnode {
	ElemType data; // 结点的数据域
	struct Lnode *next; // 结点的指针域
} Lnode, *LinkList; 
// LinkList 是指向 Lnode 结构体的指针类型
```
### 3.2单链表基本运算的实现

**单链表初始化**
创建一个空链表，并生成头结点，头指针指向头结点，头结点的指针域为 `NULL`
```C
int InitList(LinkList *L) {
	*L = (LinkList)malloc(sizeof(Lnode));
	if(!(*L)) return 0;
	(*L)->next = NULL;
	return 1;
}
```

**判断链表是否为空**
```C
int ListEmpty(LinkList L) {
	return L->next == NULL;
}
```

**单链表销毁**
从头结点开始，依次释放所有结点。删除每个结点之前，保存下一个结点的地址
```C
int DestroyList_L(LinkList *L) {
	Lnode *p;
	while (*L) {
		p = *L;
		*L = (*L)->next; // 更新 L 为下一个结点
		free(p);
	}
	return 1;
}
```

**清空单链表**
链表仍然存在，但链表中的元素被删除。头结点保持不变，指针域设置为空
```C
int  ClearList(LinkList *L) {
	Lnode *p = L->next, *q;
	 // 从首元结点开始
	while (p) {
		q = p->next; // 保存下一个结点的地址
		free(p);
		p = q; // 更新 p 为下一个结点
	}
	L->next = NULL; // 清空头结点的指针域
	return 1;
}
```

**求单链表的长度**
从首元结点开始计数，依次计算所有结点。
```C
int ListLength_L(LinkList L) {
	Lnode* p = L->next; // 从首元结点开始
	int i = 0;
	while (p) {
		i++;
		p = p->next;
	}
	return i;
}
```

**获取第i个结点的值**
从头指针开始，顺着 `next` 指针逐个查找，直到找到第 `i` 个结点
```C
int GetElem_L(LinkList L, int i, ElemType *e) {
	Lnode *p = L->next;
	int j = 1;
	while (p && j < i) { // 逐个扫描，直到找到第 i 个元素
		p = p->next;
		j++;
	}
	if (!p || j > i) return ERROR; // 第 i 个元素不存在
	*e = p->data; // 获取第 i 个元素
	return 1;
}
```

**查找指定数据的结点**
从头指针开始，依次比较数据，找到第一个与 `e` 相等的结点
```C
Lnode *LocateElem_L(LinkList L, ElemType e) {
	Lnode *p = L->next;
	while (p && p->data != e) { // 逐个比较数据
		p = p->next;
	}
	return p; // 返回结点地址，如果没有找到返回 NULL
}
```

**在第i个结点前插入值为e的结点**
找到第 `i-1` 个结点 `p`，然后将新结点插入到该结点之后
```C
int ListInsert_L(LinkList L, int i, ElemType e) {
	Lnode *p = L;
	int j = 0;
	while (p && j < i - 1) {
		p = p->next; // 找到第 i-1 个结点
		j++;
	}
	if (!p || j > i - 1) return ERROR; // 插入位置非法
	Lnode *s = (Lnode *)malloc(sizeof(Lnode));
	if(!s) return ERROR;
	s->data = e; // 创建新结点
	s->next = p->next;
	p->next = s; // 插入新结点
	return 1;
}
```

**删除第i个结点**
找到第 `i-1` 个结点，更新它的指针域，使其指向第 `i+1` 个结点
```C
int ListDelete_L(LinkList L, int i, ElemType *e) {
	Lnode *p = L;
	int j = 0;
	while (p->next && j < i - 1) { // 找到第 i-1 个结点
		p = p->next;
		j++;
	}
	if (!(p->next) || j > i - 1) return ERROR; // 删除位置非法
	Lnode *q = p->next;
	p->next = p->next->next; // 更新指针域
	e = q->data; // 存储删除结点的数据
	delete q; // 释放结点
	return 1;
}
```

**头插法**
从一个空表开始，将n个新结点依次插入到链表头部
```C
void CreateList_H(LinkList *L, int n) {
    *L = (LinkList)malloc(sizeof(LNode));  // 创建头结点
    if (*L == NULL) {
        printf("Memory allocation failed!\n");
        return;
    }
    (*L)->next = NULL;  // 初始化为空链表
    int value;
    for (int i = 0; i < n; i++) {
        LNode *p = (LNode *)malloc(sizeof(LNode));  // 创建新结点
        if (p == NULL) {
            printf("Memory allocation failed!\n");
            return;
        }  
        // 输入数据
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &value);
        p->data = value;
        p->next = (*L)->next;  // 新结点的 next 指向当前头结点的下一个结点
        (*L)->next = p;  // 头结点的 next 指向新结点
    }
}
```

**尾插法**
从一个空表开始，将n个新结点依次插入到链表尾部
```C
void CreateList_R(LinkList *L, int n) {
    *L = (LinkList)malloc(sizeof(LNode));  // 创建头结点
    if (*L == NULL) {
        printf("Memory allocation failed!\n");
        return;
    }
    (*L)->next = NULL;  // 初始化为空链表 
    LNode *r = *L;  // r 是尾指针，初始时指向头结点
    int value;
    for (int i = 0; i < n; i++) {
        LNode *p = (LNode *)malloc(sizeof(LNode));  // 创建新结点
        if (p == NULL) {
            printf("Memory allocation failed!\n");
            return;
        }  
        // 输入数据
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &value);
        p->data = value;
        
        p->next = NULL;  // 新结点的 next 指向 NULL
        r->next = p;  // 尾指针的 next 指向新结点
        r = p;  // 更新尾指针
    }
}
```

### 3.3算法效率分析
1. **查找**：时间复杂度为 O(n)，因为需要遍历所有结点。
2. **插入与删除**：查找插入或删除位置的时间复杂度为 O(n)，插入和删除操作的时间复杂度为 O(1)，因此总的时间复杂度为 O(n)。

## 4.循环链表的存储及基本运算的实现
### 4.1循环链表存储结构的类型定义
循环链表是一种首尾相接的链表，即表中最后一个结点的指针域指向头结点，整个链表形成一个环；
**非空表**：头指针指向首元节点，链表中最后一个元素的指针域也指向首元节点；

**空表**：如果有一个空的单循环链表，那么它的头结点的指针域指向本身；

**尾指针表示**：由于对表的操作都是在表的首尾进行，对于头指针表示的单循环链表，找到尾节点的时间复杂度为O(n)，不是很方便；我们对于单循环链表，通常用**尾指针R**表示，链表为空时，没有。
![[Pasted image 20250706012458.png]]

循环链表存储结点结构与单链表相同，代码如下：
```C
typedef struct Lnode {
	ElemType data; 
	struct Lnode *next; 
} Lnode, *LinkList; 
```
### 4.2循环链表基本运算的实现

**循环链表的初始化**

```C
int InitList(LinkList *L) {
	*L = (LinkList)malloc(sizeof(Lnode));
	 if (!(*L)) return 0;
	  (*L)->next = *L; // 形成循环，next指向自身
	   return 1; 
}
```

**尾插法**

用头指针表示：
```C
int InsertTail(LinkList L, ElemType e) {
	if (L == NULL) return 0; 
	// 创建新节点
	Lnode *newNode = (Lnode*)malloc(sizeof(Lnode)); 
	if (!newNode) return -1; 
	newNode->data = e; 
	// 找尾节点，尾节点是next指向头节点的那个节点
	Lnode *tail = L; 
	while (tail->next != L) {
		tail = tail->next; 
	} 
	// 插入新节点到尾部 
	tail->next = newNode; 
	newNode->next = L; // 新节点next指向头节点，保持循环性
	return 1; }
```

用尾指针表示：
```C
int InsertTail(LinkList *tail, ElemType e) {
    if (!tail) return 0;

    Lnode *newNode = (Lnode*)malloc(sizeof(Lnode));
    if (!newNode) return -1;

    newNode->data = e;

    if (*tail == NULL) {
        // 空链表，新节点指向自身，tail指向新节点
        newNode->next = newNode;
        *tail = newNode;
    } else {
        // 新节点指向头节点
        newNode->next = (*tail)->next;
        // 尾节点指向新节点
        (*tail)->next = newNode;
        // 更新尾指针为新节点
        *tail = newNode;
    }

    return 1;
}
```

**头插法**

用头指针表示：
```C
int InsertHead(LinkList L, ElemType e) { 
	if (!L) return 0; 
	Lnode *newNode = (Lnode*)malloc(sizeof(Lnode)); 
	if (!newNode) return -1; 
	newNode->data = e;
	 // 新节点指向原第一个节点
	newNode->next = L->next; 
	// 头结点指向新节点 
	L->next = newNode;
	 return 1;
}
```

用尾指针表示：
```C
int InsertHead(LinkList *tail, ElemType e) {
    if (!tail) return 0;  // 参数检查

    Lnode *newNode = (Lnode*)malloc(sizeof(Lnode));
    if (!newNode) return -1;  // 内存分配失败

    newNode->data = e;

    if (*tail == NULL) {
        // 空链表，newNode指向自身，tail指向newNode
        newNode->next = newNode;
        *tail = newNode;
    } else {
        // 非空链表，新节点指向头节点（tail->next）
        newNode->next = (*tail)->next;
        // 尾节点指向新节点，新节点成为头节点
        (*tail)->next = newNode;
    }

    return 1;  // 成功
}
```

**循环链表的遍历**
循环链表的遍历与普通链表不同，不能通过判断节点指针是否为NULL来结束遍历，而是通过判断是否回到了起始节点（通常是首元结点）来停止

用头指针表示：
```C
void PrintList(LinkList L) {
    if (L == NULL) {
        printf("链表为空\n");
        return;
    }
    Lnode *p = L->next;  // 首元结点
    if (p == L) {        // 只有头结点，链表为空
        printf("链表为空\n");
        return;
    }
    do {
        printf("%d ", p->data);
        p = p->next;
    } while (p != L->next);
    printf("\n");
}
```

用尾指针表示：
```C
void PrintListByTail(LinkList tail) {
    if (tail == NULL) {
        printf("链表为空\n");
        return;
    }
    Lnode *p = tail->next;  // 头节点
    do {
        printf("%d ", p->data);
        p = p->next;
    } while (p != tail->next);
    printf("\n");
}
```


**循环链表的合并**
思路：
1. 新建指针 `p`：用于存储表A的头结点的指针（即表A的首元结点）
2. 将表A的尾结点的后继指针指向表B的首元结点
3. 释放表B的头结点
4. 修改表B的尾结点的后继指针，使其指向表A的头结点，形成新的循环链表
![[Pasted image 20250308145311.png]]
```C
LinkList Connect(LinkList Ta,LinkList Tb){ //注意,循环链表是用尾指针表示的
	LinkList p;
	p=Ta->next; //储存表头结点
	Ta->next = Tb->next->next; //将表A的表尾与表B的表头相连
	delete Tb->next;
	Tb->next = p;
	return Tb;
}
```

## 5.双向链表的存储及基本运算的实现

*为什么需要双向链表？*

**单链表的局限性**：
- 前驱结点查找困难：单链表每个结点只存储指向后继结点的指针，因此查找某结点的前驱结点需要从头遍历链表，时间复杂度为 O(n)
- 后继结点查找简单：查找某结点的后继结点只需要 O(1) 时间

为此，我们还需要设计额外的一组指针域，从尾部指向头部，方便从后向前查找整个链表
### 5.1双向链表存储结构的类型定义

**双向链表**：
- 在每个结点中增加一个指向前驱结点的指针（`prior`），使得既能便捷地查找前驱结点，也能快速访问后继结点。
- 这样，对于任何一个结点，查找其前驱和后继结点的时间都可以保持 O(1)。

**双向循环链表**
和单链表类似，双向链表也有循环链表：
- 头结点的前驱指针指向链表的最后一个结点。
- 最后一个结点的后继指针指向头结点。

![[Pasted image 20250706025221.png]]

代码实现如下（普通双向链表）：
```C
typrdef struct DuLNode{
	Elemtype data;
	struct DulNode *prior,*next; 
}DulNode,*DuLinkList;
```
### 5.2双向链表的对称性

![[Pasted image 20250706025557.png|500]]
对于链表中的非表头表尾结点 `p`，都成立以下关系：
```C
p->prior->next = p = p->next->prior
```

- 显而易见，通过一个元素前驱的后继或者它后继的前驱都能找到这个元素，对比单链表，查询元素的效率大大提高了
- 对双向链表进行`ListLength`，`GetElem`等操作，只涉及一个方向的指针，算法与线性链表相同；但是对于删除或者插入等操作，因为需要修改两个方向上的指针，会有些不同

### 5.3双向链表基本运算的实现
前面讲到，因为一些操作只涉及到一个方向上的指针，与单链表相同，就不多说了，可以仿造[[线性表]]里的操作进行
下面来探讨双向链表的插入和删除操作：

**双向链表的插入**
算法思路：
1. 将前结点的地址赋值给插入结点的前驱结点
2. 将插入结点的地址放入前结点的后继指针域中
3. 将后结点的地址赋值给后结点的后继指针域
4. 将插入结点的地址放入后结点的前驱指针域

![[Pasted image 20250308165057.png]]
```C
int ListInsert_DuL(DuLinkList *L, int i, ElemType e) {
    DuLNode *p, *s;
    // 获取第i个结点的指针
    if (!(p = GetElemP_DuL(L, i))) return ERROR;   
    // 新建插入结点
    s = (DuLNode*)malloc(sizeof(DuLNode)); 
    s->data = e;  
    // 插入结点
    s->prior = p->prior;        // 新结点的前驱指向前结点的前驱
    p->prior->next = s;         // 前结点的前驱结点的后继指向新结点
    s->next = p;                // 新结点的后继指向原结点
    p->prior = s;               // 原结点的前驱指向新结点   
    return 1;
}
```

**双向链表的删除**
算法思路：
1. 将后结点的地址赋值给前结点的后指针域
2. 将前结点的地址赋值给后指针的前指针域
3. 释放被删除结点的内存
```C
int ListDelete_DuL(DuLinkList *L, int i, ElemType *e) {
    DuLNode *p;
    // 获取第i个结点的指针
    if (!(p = GetElem_DuL(L, i))) return ERROR;
    // 保存删除结点的数据
    *e = p->data;
    // 删除结点操作
    p->prior->next = p->next;      // 前结点的后继指向删除结点的后结点
    p->next->prior = p->prior;     // 后结点的前驱指向删除结点的前结点
    free(p);  // 释放删除的结点
    return 1;
}
```

### 5.4单链表，循环链表与双向链表比较

| 表类/操作                | 查找表头结点（首元结点）      | 查找表尾结点                   | 查找结点* p的前驱结点               |
| -------------------- | ----------------- | ------------------------ | -------------------------- |
| 带头结点的**单链表**         | L->next，时间复杂度O(1) | 从L->next依次向后遍历，时间复杂度O(n) | 通过p->next无法找到其前驱           |
| 带头结点**仅设头指针L**       | L->next，时间复杂度O(1) | 从L->next依次向后遍历，时间复杂度O(n) | 通过p->next可以找到其前驱，时间复杂度O(n) |
| 带头结点**仅设尾指针R**的循环单链表 | R->next，时间复杂度O(1) | 就是R，时间复杂度O(1)            | 通过p->next可以找到其前驱，时间复杂度O(n) |
| 带头结点的**双向循环链表L**     | L->next，时间复杂度O(1) | L->prior，时间复杂度O(1)       | p->prior，时间复杂度O(1)         |
# 四、线性表总结

| **类别**     | **顺序表**                                               | **链式存储结构（链表）**                        |
| ---------- | ----------------------------------------------------- | ------------------------------------- |
| **存储结构**   | 连续的内存空间，逻辑顺序与物理顺序一致                                   | 非连续内存空间，通过指针连接各结点形成逻辑顺序               |
| **存储密度**   | 高，存储密度=1（无指针开销）                                       | 低，存储密度 < 1（每个结点需额外存储指针，占用额外空间）        |
| **空间利用**   | 预分配固定大小空间，可能造成空间浪费或溢出，扩容时需整体搬移元素                      | 动态分配结点空间，无需预分配，空间利用灵活，但指针占用额外空间       |
| **访问方式**   | 支持随机访问，时间复杂度O(1)                                      | 只能顺序访问，查找第i个元素需遍历，时间复杂度O(n)           |
| **插入删除**   | 插入删除时需移动大量元素，时间复杂度O(n)                                | 只需修改指针，插入删除时间复杂度为O(1)（已知位置时）          |
| **存储密度公式** | 存储密度 = 结点数据本身占用空间 / 结点总空间 = 1                         | 存储密度 = 结点数据本身占用空间 / （结点数据 + 指针空间），小于1 |
| **优点**     | 1. 存储密度大  <br>2. 支持随机访问，访问速度快                         | 1. 动态分配空间，灵活  <br>2. 插入删除操作高效，无需移动元素  |
| **缺点**     | 1. 插入删除效率低，需移动元素  <br>2. 空间利用率低，扩容复杂  <br>3. 需要连续内存空间 | 1. 存储密度低，指针占空间  <br>2. 只能顺序访问，访问速度慢   |
| **适用场景**   | 1. 表长变化不大，能预知大小  <br>2. 频繁访问，少插入删除操作                  | 1. 表长变化大，无法预知大小  <br>2. 频繁插入删除操作      |

# 五、线性表的应用
## 1.约瑟夫问题
设由n个人围坐在一个圆桌周围，现从第s个人开始从1报数，数到m的人出列，然后从出列的下一个人重新开始从1报数，数到m的人再出列……如此反复，直到所有的人都出列，求出出列的次序

**单链表实现思路**：
1. 将n个人编号1~n，构建一个**单向循环链表**，最后一个节点指向第一个节点，形成环
2. 从指定的起始节点开始，顺序报数，数到第m个节点时将其删除（出列）
3. 删除节点后，从被删除节点的下一个节点继续报数，直到链表为空
4. 输出每个出列节点的编号，即为出列顺序

**代码实现**
```C
#include <stdio.h>
#include <stdlib.h>

// 循环链表解法
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 创建循环链表
Node* CreateCircleList(int n) {
    if (n <= 0) return NULL;
    
    Node *head = NULL, *tail = NULL;
    for (int i = 1; i <= n; i++) {
        Node *newNode = (Node*)malloc(sizeof(Node));
        newNode->data = i;
        newNode->next = NULL;
        
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    tail->next = head;  // 形成循环
    return head;
}

// 约瑟夫问题求解
void Josephus_Circle(int n, int start, int m) {
    Node *head = CreateCircleList(n);
    if (!head) return;
    
    // 找到起始节点及其前驱
    Node *p = head, *prev = NULL;
    while (p->data != start) {
        prev = p;
        p = p->next;
    }
    if (!prev) {  // start是头节点
        prev = head;
        while (prev->next != head) prev = prev->next;
    }
    
    printf("出列顺序: ");
    while (p->next != p) {  // 多于一个节点
        // 报数到m-1
        for (int count = 1; count < m; count++) {
            prev = p;
            p = p->next;
        }
        // 删除p节点
        printf("%d ", p->data);
        prev->next = p->next;
        free(p);
        p = prev->next;
    }
    printf("%d\n", p->data);
    free(p);
}

int main() {
    int n, s, m;
    printf("请输入总人数n, 起始位置s, 报数间隔m: ");
    scanf("%d%d%d", &n, &s, &m);
    
    printf("循环链表解法:\n");
    Josephus_Circle(n, s, m);
    
    return 0;
}
```


## 2.图书管理系统
为了方便图书的添加和删改，我们在这里使用**单链表**实现。
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ID_LEN 20
#define MAX_NAME_LEN 50

// 图书结构体
typedef struct {
    char id[MAX_ID_LEN];
    char name[MAX_NAME_LEN];
    int price;
} Book;

// 链表结点
typedef struct LNode {
    Book data;
    struct LNode *next;
} LNode, *LinkList;

// 初始化
LinkList InitLibrary() {
    LinkList head = (LinkList)malloc(sizeof(LNode));
    if (!head) {
        printf("内存分配失败!\n");
        exit(1);
    }
    head->next = NULL;
    return head;
}

// 添加图书（尾插法）
void AddBook(LinkList library, Book book) {
    LNode *newNode = (LNode*)malloc(sizeof(LNode));
    if (!newNode) {
        printf("内存分配失败!\n");
        return;
    }
    newNode->data = book;
    newNode->next = NULL;
    
    LNode *p = library;
    while (p->next) p = p->next;
    p->next = newNode;
    printf("图书 %s 已添加成功\n", book.id);
}

// 删除图书
void DeleteBook(LinkList library, const char* id) {
    LNode *current = library;
    while (current->next && strcmp(current->next->data.id, id) != 0) {
        current = current->next;
    }
    
    if (current->next) {
        LNode *temp = current->next;
        current->next = temp->next;
        free(temp);
        printf("图书 %s 删除成功\n", id);
    } else {
        printf("未找到图书: %s\n", id);
    }
}

// 查找图书
LNode* FindBook(LinkList library, const char* id) {
    LNode *p = library->next;
    while (p) {
        if (strcmp(p->data.id, id) == 0) return p;
        p = p->next;
    }
    return NULL;
}

// 显示所有图书
void DisplayBooks(LinkList library) {
    LNode *p = library->next;
    if (!p) {
        printf("图书馆为空!\n");
        return;
    }
    
    printf("\n图书列表:\n");
    printf("ID\t\t名称\t\t价格\n");
    printf("----------------------------------------\n");
    while (p) {
        printf("%s\t%s\t\t%d\n", p->data.id, p->data.name, p->data.price);
        p = p->next;
    }
    printf("----------------------------------------\n");
}

// 释放内存
void FreeLibrary(LinkList library) {
    LNode *current = library;
    while (current) {
        LNode *temp = current;
        current = current->next;
        free(temp);
    }
}

// 主菜单
void ShowMenu() {
    printf("\n========== 图书管理系统 ==========\n");
    printf("1. 添加图书\n");
    printf("2. 删除图书\n");
    printf("3. 查找图书\n");
    printf("4. 显示所有图书\n");
    printf("5. 退出\n");
    printf("==================================\n");
    printf("请选择操作: ");
}

int main() {
    LinkList library = InitLibrary();
    int choice;
    Book book;
    char searchId[MAX_ID_LEN];
    
    while (1) {
        ShowMenu();
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                printf("请输入图书ID: ");
                scanf("%s", book.id);
                printf("请输入图书名称: ");
                scanf("%s", book.name);
                printf("请输入图书价格: ");
                scanf("%d", &book.price);
                AddBook(library, book);
                break;
                
            case 2:
                printf("请输入要删除的图书ID: ");
                scanf("%s", searchId);
                DeleteBook(library, searchId);
                break;
                
            case 3:
                printf("请输入要查找的图书ID: ");
                scanf("%s", searchId);
                LNode *found = FindBook(library, searchId);
                if (found) {
                    printf("找到图书:\n");
                    printf("ID: %s\n", found->data.id);
                    printf("名称: %s\n", found->data.name);
                    printf("价格: %d\n", found->data.price);
                } else {
                    printf("未找到图书: %s\n", searchId);
                }
                break;
                
            case 4:
                DisplayBooks(library);
                break;
                
            case 5:
                FreeLibrary(library);
                printf("感谢使用，再见!\n");
                return 0;
                
            default:
                printf("无效的选择，请重新输入!\n");
        }
    }
    
    return 0;
}
```


