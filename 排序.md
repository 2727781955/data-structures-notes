---
time: 2025-06-24
author: Fang
tags:
  
---
本节我们来学习几种排序算法
# 一、排序相关概念
排序是将一组无序的数据按照某种规则（如数值大小、字典顺序等）重新排列成有序序列的过程

## 1.排序的分类

**1. 按数据存储介质**
- 内部排序：所有数据都存储在内存中进行排序，适用于数据量较小的场景
- 外部排序：数据量过大，需要借助外部存储（如磁盘）进行排序，常用于大数据处理

**2. 按比较器个数**
- 串行排序：排序过程在单一处理器或单线程上顺序执行，同一时刻只比较一对元素
- 并行排序：利用多处理器或多线程同时进行排序，同一时刻比较多对元素

**3. 按主要操作类型**
- 比较排序：通过元素之间的比较实现排序，如快速排序、归并排序、堆排序等
- 基数排序：不直接比较元素大小，而是根据元素本身取值确定位置

**4. 按辅助空间需求**
- 原地排序：排序过程中只需O(1)的额外空间，如选择排序、插入排序、堆排序
- 非原地排序：需要额外开辟较多空间(超过O(1)的空间)，如归并排序、计数排序

**5. 按稳定性**
- 稳定排序：相等元素排序前后的相对位置不变，如冒泡排序、归并排序、插入排序
- 非稳定排序：相等元素排序前后的相对位置可能改变，如快速排序、选择排序、堆排序

**6. 按自然性**
- 自然排序：排序算法能够自动识别并利用输入数据中已经存在的有序部分进行优化，如自然归并排序
- 非自然排序：算法不会利用数据中已有的有序信息


# 二、插入排序

插入排序（Insertion Sort）是一种简单直观的排序算法，通过构建有序序列，在未排序序列中从后向前扫描，为新元素找到对应位置并插入；它在实现上通常采用原地排序，即只需要用到O(1)的额外空间

## 1.算法思想
- 对于一个序列，在插入a\[i]之前，序列a的前半段(a\[0]~a\[i-1])是已排序序列，后半段(a\[i]~a\[n-1])是带排序序列
- 插入a\[i]使a\[0]~a\[i-1]有序，也就是要为a\[i]找到有序位置j（0<=j<=i），将a\[i]插入到a\[j]的位置上
   
根据插入位置查找的方式不同，我们将插入排序分为三种：
- 顺序法定位插入位置——直接插入法
- 二分法定位插入位置——二分插入法
- 缩小增量多遍插入排序——希尔排序

## 2.直接插入排序
直接插入排序（Straight Insertion Sort）是一种简单直观的插入排序算法，其核心思想是将待排序序列分为已排序区和未排序区，**使用顺序查找法依次将未排序区的元素插入到已排序区的合适位置**，从而使整个序列有序

**算法思像**
- 初始时，将序列的第一个元素视为已排序区，剩余元素为未排序区
- 从未排序区依次取出元素，按从后向前的顺序扫描已排序区，找到该元素应插入的位置
- 将比该元素大的已排序元素依次后移，为新元素腾出插入位置
- 将新元素插入到合适位置，继续处理下一个未排序元素
- 重复以上过程直到所有元素均被插入排序完成

如果遇到待插入元素与已排序区中某个元素相等，通常将新元素插入到相等元素的后面，保证排序的稳定性

**代码实现**
直接插入排序，省略判别数组越界的操作，我们也可以在数组头部插入哨兵元素来进行判别
```C
void insertSort(SqList *L) {
    int i, j;
    for (i = 2; i <= L->length; i++) {
        if (L->r[i].key < L->r[i - 1].key) {          
            L->r[0] = L->r[i];                         // 复制插入元素为哨兵
            for (j = i - 1; L->r[0].key < L->r[j].key; --j) {
                L->r[j + 1] = L->r[j];                 // 元素后移
            }
            L->r[j + 1] = L->r[0];                     // 插入到正确位置
        }
    }
}
```

**示例**
假设待排序数组：{312, 126, 272, 226, 28, 165, 123}，求排序序列
*排序过程如下：*

| 步骤 | 当前插入元素 | 已排序区                               | 未排序区                          |
| -- | ------ | ---------------------------------- | ----------------------------- |
| 初始 | -      | {312}                              | {126, 272, 226, 28, 165, 123} |
| 1  | 126    | {126, 312}                         | {272, 226, 28, 165, 123}      |
| 2  | 272    | {126, 272, 312}                    | {226, 28, 165, 123}           |
| 3  | 226    | {126, 226, 272, 312}               | {28, 165, 123}                |
| 4  | 28     | {28, 126, 226, 272, 312}           | {165, 123}                    |
| 5  | 165    | {28, 126, 165, 226, 272, 312}      | {123}                         |
| 6  | 123    | {28, 123, 126, 165, 226, 272, 312} | {}                            |

**性能分析**
直接排序实现的基本操作有两个：
1. 比较序列中两个关键字的大小
2. 移动记录

操作的次数与序列本身有关联：
- 最好的情况：关键字在记录序列中顺序有序，则比较次数为$\sum_{i=2}^nn-1$，移动次数为0
- 最坏的情况：关键字在记录序列中逆序有序，则比较次数为$\sum_{i=2}^ni{\frac{(n+2)(n-1)}{2}}$，移动次数为$\sum_{i=2}^n(i+1){\frac{(n+4)(n-1)}{2}}$

所以：
- 最好情况下，时间复杂度为$O(n)$
- 最坏情况下，时间复杂度为$O(n^2)$
- 平均情况下，时间复杂度为$O(n^2)$
- 空间复杂度为O(1)，属于原地排序算法
- 稳定性：稳定排序，保持相等元素的相对位置不变

## 3.折半插入排序
折半插入排序（Binary Insertion Sort）是对直接插入排序的一种改进，其核心优化在于利用**折半查找**（二分查找）来确定待插入元素在已排序序列中的正确位置，从而减少比较次数，提高查找效率

**代码实现**
```C
void BInsertSort(SqList *L) {
    int i, j, low, high, mid;
    for (i = 2; i <= L->length; ++i) { // 依次插入第2~n个元素
        L->r[0] = L->r[i]; // 当前插入元素存到“哨兵”位置

        // 折半查找插入位置
        low = 1;
        high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (L->r[0].key < L->r[mid].key)
                high = mid - 1;
            else
                low = mid + 1;
        }
        // 循环结束，high+1为插入位置

        // 移动元素
        for (j = i - 1; j >= high + 1; --j)
            L->r[j + 1] = L->r[j];

        // 插入元素
        L->r[high + 1] = L->r[0];
    }
}
```

**性能分析**
- 折半查找比顺序查找更高效，因此折半插入排序的平均性能优于直接插入排序。
- 折半插入排序的关键码比较次数只与待排序元素个数有关，**与初始序列的有序程度无关**；**插入第i个元素时，最多需要进行⌊log⁡2i⌋+1次比较来确定插入位置**
- 当元素数量较大时，折半插入排序的总比较次数远少于直接插入排序的最坏情况，但仍多于其最好情况
- 在序列已经基本有序或完全有序的情况下，直接插入排序的比较次数通常少于折半插入排序
- 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列，所以**移动次数并没有减少**

所以：
- 时间复杂度为$O(n^2)$
- 空间负杂度为$O(1)$
- 是一种稳定排序方法
## 4.希尔排序
直接插入排序的核心耗时在于每次比较后都需移动元素，尤其当待插入元素距离正确位置较远时，移动次数多，效率降低

**直接插入排序效率最高的情况：**
- 待排序序列基本有序时，元素移动和比较次数都较少，效率较高。 
- 待排序元素数量较少时，算法简单且开销小，表现良好。
    
基于此，我们引出了**希尔排序**——希尔排序通过“分组插入排序”思想，**将序列按一定间隔分组，对每组分别进行插入排序，逐步缩小间隔，使序列逐渐接近有序，最终再进行一次间隔为1的直接插入排序**
这样，希尔排序在前期大幅减少逆序对，显著降低了后期插入排序的移动次数，从而整体提升排序效率

**算法思想**
- 将待排序序列按一定的增量（gap）分成若干组，组内元素间隔为gap
- **对每组分别进行直接插入排序**
- 缩小增量（增量之间最好是互质的），重复上述过程，**最后一个增量必须为1**
- 当增量缩小到1时，进行一次普通插入排序，完成最终排序

**代码实现**
```C
void ShellInsert(SqList *L, int dk) {
    int i, j;
    for (i = dk + 1; i <= L->length; ++i) {
        if (L->r[i].key < L->r[i - dk].key) {
            L->r[0] = L->r[i];  // 哨兵暂存待插入元素
            j = i - dk;
            while (j > 0 && L->r[0].key < L->r[j].key) {
                L->r[j + dk] = L->r[j];
                j -= dk;
            }
            L->r[j + dk] = L->r[0];  // 插入哨兵元素
        }
    }
}

void ShellSort(SqList *L, int dlta[], int t) {
    int k;
    for (k = 0; k < t; ++k) {
        ShellInsert(L, dlta[k]);
    }
}
```

**示例**
假设待排序数组：{312, 126, 272, 226, 28, 165, 123}，求排序序列
*排序过程如下*：
我们用采用经典的增量序列：gap = 3, 1

>初始gap一般取长度的一半向下取整

**第一步：gap = 3**
将数组分成3组，分别对每组进行插入排序：

| 组别 | 索引序列    | 初始元素          | 插入排序过程                           | 排序后结果         |
| -- | ------- | ------------- | -------------------------------- | ------------- |
| 组1 | 0, 3, 6 | 312, 226, 123 | 226 < 312 → 交换<br>123 < 226 → 交换 | 123, 226, 312 |
| 组2 | 1, 4    | 126, 28       | 28 < 126 → 交换                    | 28, 126       |
| 组3 | 2, 5    | 272, 165      | 165 < 272 → 交换                   | 165, 272      |


**第二步：gap = 1**——对整个数组进行一次普通插入排序

| 步骤 | 当前元素 | 操作描述              | 数组状态                               |
| -- | ---- | ----------------- | ---------------------------------- |
| 初始 | -    | 从gap=3的结果开始       | {123, 28, 165, 226, 126, 272, 312} |
| 1  | 28   | 28 < 123，交换       | {28, 123, 165, 226, 126, 272, 312} |
| 2  | 165  | 165 > 123，不动      | {28, 123, 165, 226, 126, 272, 312} |
| 3  | 226  | 226 > 165，不动      | {28, 123, 165, 226, 126, 272, 312} |
| 4  | 126  | 126 < 226，插入到正确位置 | {28, 123, 126, 165, 226, 272, 312} |
| 5  | 272  | 272 > 226，不动      | {28, 123, 126, 165, 226, 272, 312} |
| 6  | 312  | 312 > 272，不动      | {28, 123, 126, 165, 226, 272, 312} |

最终排序结果：{28, 123, 126, 165, 226, 272, 312}

**性能分析**
- 希尔排序的算法效率于增量序列（gap序列）的取值有关：
	- **Shell原始序列**（gap = n/2, n/4, ..., 1）：  
	    简单易实现，但最坏情况复杂度为 $O(n^2)$ 
	- **Hibbard序列**（gap = 1, 3, 7, 15, ...，即 $2^{k−1}$）：  
	    最坏情况复杂度约为 $O(n^{3/2})$
	- **Sedgewick序列**等其他复杂序列：  
	    可以进一步降低最坏情况复杂度，接近 $O(n^{4/3})$，甚至更优
- 合理的增量序列下，希尔排序的平均时间复杂度约为$O(n^{1.25}∼1.6n^{1.25})$
- 希尔排序是**原地排序算法**，空间复杂度为O(1)
- 希尔排序在多个不同增量的分组排序过程中，相等元素可能会被分到不同组中并发生交换，导致它们的相对位置被改变，从而破坏了稳定性，所以**希尔排序是不稳定排序**


# 三、交换排序
交换排序是一类基于**比较和交换操作**的排序算法，核心思想是通过不断比较序列中元素的大小关系，并在不满足排序要求时**交换它们的位置**，逐步将序列排序完成
## 1.算法思想
- 交换排序通过两两比较元素的关键字大小
- 当发现两个元素的顺序不符合排序要求时，交换它们的位置
- 经过多趟比较和交换，较大（或较小）的元素逐渐移动到序列的一端，最终实现整个序列的有序

- 典型的交换排序算法有**冒泡排序和快速排序**

下面分别介绍这两种算法
## 2.冒泡排序
冒泡排序（Bubble Sort）是一种最直接的交换排序，通过逐个比较元素之间的相对大小来并交换，来确定元素之间的相对位置

**算法思想**
- 将序列看作未排序区和已排序区，初始时整个序列为未排序区
- 通过相邻元素两两比较，将较大的元素逐一比较，逐步“冒泡”到序列末尾  
- 每一趟排序完成后，未排序区长度减一，循环执行冒泡算法，直到全部排序完成

**代码实现**
```C
void BubbleSort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

**举例**
假设待排序的数组为：64,34,25,12,22,11,90，求排序序列

*排序过程如下*：
一共有7个元素，所以需要比较6趟

**第1趟排序**（将最大元素“冒泡”到末尾）：
- 比较64和34，64 > 34，交换，数组变为 34,64,25,12,22,11,90
- 比较64和25，64 > 25，交换，数组变为 34,25,64,12,22,11,90
- 比较64和12，64 > 12，交换，数组变为 34,25,12,64,22,11,90
- 比较64和22，64 > 22，交换，数组变为 34,25,12,22,64,11,90
- 比较64和11，64 > 11，交换，数组变为 34,25,12,22,11,64,90
- 比较64和90，64 < 90，不交换，数组保持 34,25,12,22,11,64,90
    
此时，最大元素90已排到数组末尾

**第2趟排序**（将次大元素“冒泡”到倒数第二位）：
- 比较34和25，34 > 25，交换，数组变为 25,34,12,22,11,64,90
- 比较34和12，34 > 12，交换，数组变为 25,12,34,22,11,64,90
- 比较34和22，34 > 22，交换，数组变为 25,12,22,34,11,64,90
- 比较34和11，34 > 11，交换，数组变为 25,12,22,11,34,64,90
- 比较34和64，34 < 64，不交换，数组保持 25,12,22,11,34,64,90
    
次大元素64已排到倒数第二位

**第3趟排序**：
- 比较25和12，25 > 12，交换，数组变为 12,25,22,11,34,64,90
- 比较25和22，25 > 22，交换，数组变为 12,22,25,11,34,64,90
- 比较25和11，25 > 11，交换，数组变为 12,22,11,25,34,64,90
- 比较25和34，25 < 34，不交换，数组保持 12,22,11,25,34,64,90

**第4趟排序**：
- 比较12和22，12 < 22，不交换
- 比较22和11，22 > 11，交换，数组变为 12,11,22,25,34,64,90
- 比较22和25，22 < 25，不交换
    
**第5趟排序**：
- 比较12和11，12 > 11，交换，数组变为 11,12,22,25,34,64,90
- 比较12和22，12 < 22，不交换
    
**第6趟排序**：
- 比较11和12，11 < 12，不交换
    
排序完成，最终有序数组为：  11,12,22,25,34,64,90

**性能分析**
我们可以看到，每趟排序结束时，都能将最大值挤到最后面的位置上，同时还能理顺其余部分

但是算法执行过程中，也有许多无效的比较步骤，*如何改进算法提高效率呢？*
一旦某一趟比较时**不出现记录交换**，说明已经排好序了，**就可以提前结束本趟算法**
改进后的算法代码：
```C
// 优化版冒泡排序，加入提前结束标志
void BubbleSort(int arr[], int n) {
    int i, j, temp;
    int flag; // 标志位，用于检测是否发生交换
    for (i = 0; i < n - 1; i++) {
        flag = 0; // 假设本趟无需交换
        for (j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = 1; // 发生了交换，不能提前结束
            }
        }
        if (flag == 0) {
            // 本趟没有发生交换，数组已经有序，提前结束
            break;
        }
    }
}
```

- 时间复杂度：
    - 最好情况（序列已排序）：O(n)
    - 最坏和平均情况：O(n²)
    
- 空间复杂度：O(1)，原地排序
- 稳定性：稳定排序，保持相等元素相对位置不变

## 3.快速排序
快速排序是改进后的交换排序算法，**采用分治策略**，选取序列中的一个元素作为基准值（pivot），通过一趟排序将序列划分为两部分，递归地对左右两部分分别进行快速排序，直到排序完成

**算法思想**
1. 选择基准元素（pivot）：通常选择序列中的第一个元素或最后一个元素作为基准
2. 分区操作：通过一趟排序，将序列划分为两部分，使得左侧部分的所有元素都小于基准元素，右侧部分的所有元素都大于基准元素
3. 递归排序：分别对左、右两部分递归执行快速排序
4. 完成排序：当子序列长度为1或0时，递归终止，序列有序

**代码实现**
```C
void quickSort(int arr[], int left, int right) {
    if (left >= right) return;
    int i = left, j = right;
    int pivot = arr[i]; // 选取基准元素
    while (i < j) {
        while (i < j && arr[j] >= pivot) j--;
        arr[i] = arr[j]; // 将小于pivot的元素移到左边
        while (i < j && arr[i] <= pivot) i++;
        arr[j] = arr[i]; // 将大于pivot的元素移到右边
    }
    arr[i] = pivot; // 基准元素归位
    quickSort(arr, left, i - 1);  // 递归排序左侧子序列
    quickSort(arr, i + 1, right); // 递归排序右侧子序列
}
```

**举例**
有初始序列：{56, 23, 82, 45, 76, 69, 20, 45, 93, 16, 27}，求快速排序后的序列
*排序过程*：
1. **选择基准**：选第一个数56
2. **划分序列**：  
    把比56小的放左边，比56大的放右边  
    划分后序列变成：  
    20, 23, 27, 45, 16, 45, *56*, 69, 93, 76, 82
    
3. **递归排序左边**（20, 23, 27, 45, 16, 45）：  
    选20为基准，划分后：16, *20*, 23, 27, 45, 45  
    继续递归，直到左边部分有序
    
4. **递归排序右边**（69, 93, 76, 82）：  
    选76为基准，划分后：69, *76*, 93，82  
    对右边部分继续递归，以93为基准：82，*93*

5. **完成排序**：
     最终序列：16, 20, 23, 27, 45, 45, 56, 69, 76, 82, 93

**性能分析**
时间复杂度
- **平均情况**：快速排序的平均时间复杂度为$O(nlog_2⁡n)$这是因为每次划分大致将序列分成两半，递归深度约为$log⁡_2n$，每层处理元素总数为n⁡

- **最好情况**：当每次划分都能均匀分割序列（如正好一分为二），时间复杂度也是$O(nlog⁡_2n)$

- **最坏情况**：当每次划分极不均匀（例如每次选的基准是最大或最小元素），导致划分结果是一个子序列长度为n−1，另一个为空，递归深度达到n，此时时间复杂度退化为$O(n^2)$

**就平均时间而言，快速排序是所有内排序方法中最好的一个**

空间复杂度
- 快速排序是递归算法，空间复杂度主要取决于递归调用栈的深度
    
- **平均情况下**，递归深度约为$log⁡_2n$，空间复杂度为$O(log_2⁡n)$
    
- **最坏情况下**，递归深度退化为n，空间复杂度为$O(n)$
    
稳定性：
	**快速排序是一种不稳定的排序算法**

输入的数据次序越乱，所选划分元素值得随机性越好，排序速度越快，所以**快速排序不是自然排序算法**

# 三、快速排序
选择排序是一种简单直观的排序算法，属于交换排序的一种特殊形式
它的核心思想是：每一趟从未排序的序列中选出最小（或最大）元素，放到已排序序列的末尾，直到所有元素排序完成
## 1.算法思想
- 将序列分为已排序区和未排序区，初始时已排序区为空，未排序区为整个序列
- 每次从未排序区中找到最小（或最大）元素
- 将该最小元素与未排序区的第一个元素交换位置
- 已排序区长度加一，未排序区长度减一
- 重复以上步骤，直到未排序区为空，序列排序完成


- 选择排序主要有两种：
	- **简单选择排序**：每趟直接在未排序区找到最小（或最大）元素，与未排序区首元素交换
	- **堆排序**：利用堆这种特殊的树形结构，高效选出最大（或最小）元素，优化了选择过程，提高排序效率

下面来分别介绍

## 2.简单选择排序

**算法思想**
简单选择排序的核心就是**不断选择最小元素放到序列前端**，每趟**只交换一次**，减少了交换次数，但比较次数依然较多
- 主要步骤如下：
	- 在待排序序列中，**每一趟从未排序的元素中选择最小（或最大）元素**
	- 将该元素与未排序区的第一个元素交换位置
	- 这样经过第一趟后，最小元素被放到序列起始位置，已排序区长度加一，未排序区长度减一
	- 重复以上过程，直到所有元素都被排序完毕

**代码实现**
```C
void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;
    for (i = 0; i < n - 1; i++) {
        minIndex = i; // 假设当前i为最小元素位置
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 找到更小元素，更新minIndex
            }
        }
        // 交换当前i位置和minIndex位置的元素
        if (minIndex != i) {
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```

**举例**
假设待排序数组为：64, 25, 12, 22, 11，求选择排序后的序列

*排序步骤如下*：
- 第1趟：找最小元素11，和第一个元素64交换，数组变为：11, 25, 12, 22, 64
- 第2趟：找剩余元素中最小的12，和第二个元素25交换，数组变为：11, 12, 25, 22, 64
- 第3趟：找剩余元素中最小的22，和第三个元素25交换，数组变为：11, 12, 22, 25, 64
- 第4趟：找剩余元素中最小的25，已在正确位置，无需交换
- 排序完成，最终数组为：11, 12, 22, 25, 64

**性能分析**
- 无论排序的序列顺序如何，所需要的**比较次数都相同**，均为$\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}$
- 交换次数：
	- 最好情况：不需要交换，次数为0
	- 最坏情况：每一次都需要交换，次数为$n-1$，赋值次数为$3(n-1)$
所以：
- 时间复杂度为$O(n^2)$
- 空间复杂度为$O(1)$

简单选择排序**不是稳定排序算法**
# 四、堆排序
## 1.堆的定义
堆（Heap）是一种特殊的树形数据结构，满足以下两个核心特性：

- **完全二叉树结构**：堆通常表现为一棵完全二叉树，即除最后一层外，每层节点都达到最大数目，最后一层节点集中在左侧

- **堆序性质**：堆中任意节点的值都满足特定的大小关系：
    - **大根堆**：每个节点的值都大于或等于其所有子节点的值，堆顶元素是整个堆中的最大值
    - **小根堆**：每个节点的值都小于或等于其所有子节点的值，堆顶元素是整个堆中的最小值

如有以下两个序列：{98 77 35 62 55 14 35 48}、{14 48 35 62 55 98 35 77}

*我们可以得到如下的树结构*：
![[Pasted image 20250612220109.png]]
我们利用堆结构的特性，就能迅速找到最大（最小的元素），剩下的元素又能重新建成一个堆结构，这样重复n次，就能得到一个有序序列，这个过程我们称之为**堆排序**

实现堆排序需要解决两个问题：
1. 如何由一个无序序列**建成一个堆**？
2. 如何在输出堆顶元素后，**调整堆**的剩余元素为一个新的堆？

## 2.堆的相关操作

**无序序列建堆**
以大根堆为例：
- **从最后一个非叶子节点开始**（下标为n/2-1，数组下标从0开始），依次向前对每个节点执行下沉调整
    - 比较该节点与其左右子节点的值，找出最大值所在节点
    - 若最大值不是当前节点，交换两者，然后继续对被交换的子节点递归执行下沉
- 最后完成所有非叶子节点的调整后，整个序列即构成大根堆

**剩余元素建堆**（下浮调整算法）
以大根堆为例：
- 将堆顶元素（最大值）与堆尾元素交换，移除堆尾元素（即最大值已排序）
- 对新的堆顶元素执行下沉调整
    - 比较该节点与其左右子节点，找出最大值节点
    - 若最大值不是当前节点，交换并继续向下调整，直到堆性质恢复

**举例**
我们有序列{10, 2, 11, 8, 7}，求其构建大根堆的过程和去除根元素后堆结构的重建过程

*构建大根堆：*
待排序序列：{10, 2, 11, 8, 7}
将其看成完全二叉树（数组下标从0开始）：
```
          10(0)
         /     \
      2(1)     11(2)
     /    \
   8(3)   7(4)
```

**步骤1：找到最后一个非叶子节点**  
节点索引为(n-2)/2 = (5-2)/2 = 1，即节点2（索引1）

**步骤2：从最后一个非叶子节点开始向前调整堆**
- 调整节点2（值为2）：
    - 左子节点8（索引3），右子节点7（索引4）
    - 最大子节点为8，8 > 2，交换2和8
    - 交换后子树变为：节点8（索引1），节点2（索引3）
    - 继续对节点2（索引3）下沉，节点2为叶子，无需继续调整

序列变为：{10, 8, 11, 2, 7}

- 调整节点0（值为10）：
    - 左子节点8（索引1），右子节点11（索引2）
    - 最大子节点为11，11 > 10，交换10和11
    - 交换后子树变为：节点11（索引0），节点10（索引2）
    - 继续对节点10（索引2）下沉，节点10无子节点，无需继续调整
        
序列变为：{11, 8, 10, 2, 7}

此时整个序列满足大根堆性质


*输出堆顶元素后调整堆：*

输出堆顶元素11，将堆尾元素7放到堆顶：
    
序列变为：{7, 8, 10, 2, 11}（将11放末尾，不参与后续堆调整）

- 对堆顶7执行下沉调整：
    - 左子节点8，右子节点10，最大子节点为10
    - 10 > 7，交换7和10 
    - 继续对节点7（索引2）下沉，节点7无子节点，调整结束
        
序列变为：{10, 8, 7, 2, 11}

**代码实现**
```C
//下浮调整函数
void heapify(int arr[], int n, int i) {
    int largest = i;          // 初始化最大值为当前节点
    int left = 2 * i + 1;     // 左子节点索引
    int right = 2 * i + 2;    // 右子节点索引

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        // 交换父节点和最大子节点
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // 递归调整被交换的子节点
        heapify(arr, n, largest);
    }
}

//无序建堆使用整理函数来实现
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始，向前调整每个节点
    for (int i = (n - 2) / 2; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```
## 3.堆排序实现
**建堆**：从最后一个非叶子节点开始（索引为 $⌊\frac{n−2}2⌋$），依次向前对每个节点执行“下沉调整”（heapify算法），使其子树满足大顶堆性质

**堆排序**：
    - 逐步输出堆顶元素，并将堆顶元素与堆尾元素交换，堆大小减1
    - 对新的堆顶元素执行“下沉调整”，恢复堆结构
    - 重复上述过程直到堆大小为1

**代码实现**
```C
void heapSort(int arr[], int n) {
    buildMaxHeap(arr, n);  // 构建大根堆

    for (int i = n - 1; i > 0; i--) {
        swap(&arr[0], &arr[i]);  // 将堆顶最大元素放到末尾
        heapify(arr, i, 0);      // 调整剩余元素为大根堆
    }
}
```

**性能分析**
- 时间复杂度：
    - 建堆时间复杂度为 O(n)
    - 每次调整堆时间复杂度为$O(log⁡_2n)$，共进行$n−1$次调整
    - 整体时间复杂度为$O(log⁡_2n)$
        
- 空间复杂度：原地排序，空间复杂度为O(1)
- 稳定性：堆排序是不稳定的排序算法

# 五、归并排序
      
归并排序（Merge Sort）是一种基于**分治法**的排序算法，它的基本思想是：**先将序列划分为若干子序列，分别排序后再合并成一个有序序列**；归并排序是一种稳定的排序算法，适用于处理大规模数据排序
## 1.算法思想

归并排序遵循“**分而治之**”的思想，主要包括以下三个步骤：
1. **分解**：将原始序列从中间划分为两个子序列
2. **解决**：递归地对两个子序列分别进行归并排序
3. **合并**：将两个已排序的子序列合并为一个有序序列
    
这个过程一直递归到每个子序列长度为1，然后开始合并过程

归并排序的核心是“分”和“治”：
- **分**：将序列递归拆分为更小的子序列
- **治**：将有序的子序列合并成更大的有序序列
    
**代码实现**
```C
// 合并两个有序子序列
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子序列长度
    int n2 = right - mid;     // 右子序列长度

    // 创建临时数组
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    // 合并两个子序列
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j])
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    // 复制剩余元素
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// 归并排序递归函数
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);        // 排序左半部分
        mergeSort(arr, mid + 1, right);   // 排序右半部分
        merge(arr, left, mid, right);     // 合并两个有序部分
    }
}

```

**举例**
排序序列：\[38, 27, 43, 3, 9, 82, 10]

拆分过程：
\[38, 27, 43, 3, 9, 82, 10]
→ \[38, 27, 43, 3] 和 \[9, 82, 10]
→ \[38, 27] \[43, 3] \[9, 82] \[10]
→ \[38]\[27] \[43] \[3] \[9] \[82] \[10]


合并过程：
\[38] + \[27] → \[27, 38]
\[43] + \[3]  → \[3, 43]
\[9] + \[82]  → \[9, 82]
\[27, 38] + \[3, 43] → \[3, 27, 38, 43]
\[9, 82] + \[10]     → \[9, 10, 82]
最终合并 → \[3, 9, 10, 27, 38, 43, 82]

**性能分析**
- **时间复杂度**：
    - 拆分序列的深度为$log_2n$
    - 每层合并操作需要遍历所有元素，时间为$O(n)$
    - 总体时间复杂度为$O(nlog⁡_2n)$
        
- **空间复杂度**：
    - 归并操作需要额外的辅助空间存储临时数组
    - 空间复杂度为$O(n)$
        
- **稳定性**：
    - 归并排序是稳定的排序算法，因为合并时相等元素保持原有顺序
        

# 六、基数排序

基数排序是一种非比较型的整数排序算法，通过将整数按位数切割成不同的数字，然后按每个位数分别排序，最终完成整个序列的排序；它适用于整数或者字符串排序，尤其在数据范围较大时表现优异
## 1.算法思想

- 将待排序元素拆分为若干“位”或“关键字”，如十进制数字的个位、十位、百位等
- 从最低位开始，依次对每一位进行排序（通常使用稳定的排序算法，如计数排序）
- 每次排序后，序列部分有序，最终经过所有位的排序后，整个序列有序
- 归根结底是利用多次稳定排序实现整体排序
    
**代码实现**
```C
// 计数排序作为基数排序的子过程，对arr按exp位进行排序
void countingSort(int arr[], int n, int exp) {
    int output[n]; // 输出数组
    int count[10] = {0}; // 计数数组，范围0-9

    // 统计每个数字出现次数
    for (int i = 0; i < n; i++) {
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }

    // 计算累计计数，用于确定元素位置
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // 从后向前遍历，保证排序稳定性
    for (int i = n - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    // 将排序结果复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

// 基数排序主函数
void radixSort(int arr[], int n) {
    // 找出最大值，确定最大位数
    int maxVal = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > maxVal)
            maxVal = arr[i];
    }

    // 从最低位开始，对每个位进行计数排序
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        countingSort(arr, n, exp);
    }
}
```
**举例说明**
假设待排序数组为：170, 45, 75, 90, 802, 24, 2, 66

排序过程：
- **第一轮（个位排序）**：
    - 按个位数字排序后数组变为：170, 90, 802, 2, 24, 45, 75, 66
        
- **第二轮（十位排序）**：
    - 按十位数字排序后数组变为：802, 2, 24, 45, 66, 170, 75, 90

- **第三轮（百位排序）**：
    - 按百位数字排序后数组变为：2, 24, 45, 66, 75, 90, 170, 802
        
排序完成，最终数组为：2, 24, 45, 66, 75, 90, 170, 802

**性能分析**

- **时间复杂度**：
    
    - 假设最大数字有$d$位，基数为$k$（十进制时$k=10$）
    - 每一位排序使用计数排序时间为$O(n + k)$
    - 总体时间复杂度为$O(d \times (n + k))$
    - 对于固定基数和位数，时间复杂度近似为线性$O(n)$
        
- **空间复杂度**：
    - 需要额外的计数数组和输出数组，空间复杂度为$O(n + k)$
        
- **稳定性**：
    - 基数排序依赖稳定的子排序算法，因此整体是稳定排序算法
        

# 七、各个排序算法的比较

| 排序算法 | 时间复杂度（平均） | 时间复杂度（最坏） | 空间复杂度    | **稳定性** | 备注            |
| ---- | --------- | --------- | -------- | ------- | ------------- |
| 冒泡排序 | O(n^2)    | O(n^2)    | O(1)     | 稳定      | 简单，效率低        |
| 选择排序 | O(n^2)    | O(n^2)    | O(1)     | 不稳定     | 交换次数少         |
| 插入排序 | O(n^2)    | O(n^2)    | O(1)     | 稳定      | 对部分有序数据高效     |
| 希尔排序 | O(nlog⁡n) | O(n^2)    | O(1)     | 不稳定     | 插入排序改进        |
| 归并排序 | O(nlog⁡n) | O(nlog⁡n) | O(n)     | 稳定      | 适合大数据，外部排序    |
| 快速排序 | O(nlog⁡n) | O(n^2)    | O(log⁡n) | 不稳定     | 实际最快，递归实现     |
| 堆排序  | O(nlog⁡n) | O(nlog⁡n) | O(1)     | 不稳定     | 时间稳定，空间节省     |
| 基数排序 | O(d(n+k)) | O(d(n+k)) | O(n+k)   | 稳定      | 非比较排序，适合多位关键字 |

