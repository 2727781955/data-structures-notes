---
date: 2025-03-15
author: Fang
tags:
 
---
本节我们来学习串、数组和广义表这三种数据结构

这三个概念其实都是**线性表的推广与延伸**，它们之间的关系可以从“限制”与“扩展”两个维度来理解 ：

- **串是内容受限的线性表** 。它将数据元素的类型固定为字符（如字母、数字、符号），主要关注的是字符序列的整体处理（如模式匹配、拼接等），而不是单个元素的增删 ；你可以把它看作是线性表中一种最特殊、最常用的实例 

- **数组是元素类型相同的线性表推广** 。在一维数组中，它与线性表逻辑一致；但在多维数组中，每一个数据元素本身又是一个线性表（例如二维数组的每一行都是一个一维数组）。数组强调的是通过索引进行随机存取，且一旦定义，维数和维界通常固定不变 

- **广义表是结构最灵活的线性表推广** 。它打破了“元素必须是原子类型”的限制，允许元素既可以是单个数据（原子），也可以是另一个表（子表）。因此，广义表可以实现多层次的嵌套和递归，甚至能兼容数组、树和有向图等复杂的非线性结构

从串到数组再到广义表，**数据的容纳能力和嵌套深度在不断增强**：串限定了内容，数组限定了同质，而广义表则完全开放了内容的结构化嵌套

下面来逐一介绍这三种数据结构
# 一、串
## 1.串的逻辑结构

### 1.1串的定义和相关概念
- 串(string) (或字符串）是由零个或多个字符组成的有限序列，一般记为
$$s ='a_1a_2 …a_n'(n≥0)$$
- 其中，s是串的名，用单引号括起来的字符序列是串的值； $a_i$可以是字母、数字或其他字符；串中字符的数目n称为串的长度

- 零个字符的串称为**空串**(null string), 它的长度为零

- 串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免混淆

- 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串

- 通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的**第一个字符在主串中的位置**来表示

- 有当两个串的长度相等，并且各个对应位置的字符都相等时，我们就称这两个串的长度相同。所有的空串都是相等的


## 2.串的顺序存储结构——顺序串

### 2.1串顺序存储的表示
类似于线性表的顺序存储结构，即用一组地址连续的存储单元存储串值的字符序列；在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区

串长是串的一个重要的属性，我们主要有三种不同的记录方式：
- 定义一个结构体，额外设定一个变量来记录长度
- 将串中第一个位置存储长度数据，其余位置存储字符
- 以'\0'作为串的终结标志

在C语言中，主要使用第三种方式
### 2.2顺序串的类型定义
按照上文，我们主要有三种方式来定义顺序串

1. 使用额外变量记录串长，我们规定字符串最大长度255
```C
#define MAXLEN 255
typedef struct{
    char ch[MAXLEN]; 
    int length; //记录当前字符个数
}SqString;
```

2. 将串中第一个位置存储串的长度
```C
#define MAXLEN 255
//s[0]存储串长，s[1]~s[256]存储字符
char s[MAXLEN+1];
```

3. 以'\0'作为串终结标志
```C
#define MAXLEN 255
char s[MAXLEN + 1];
```

### 2.3顺序串的基本操作
我们基于第三种定义方式来实现这些基本操作

**求串长**
```C
int StrLength(char s[]){
     int i=0;
     while(s[i]!=’\0’)   i++;
     return(i);
}
```

**串连接**
```C
int StrConcat1(char s1[],char s2[],char s[]){
	int i=0 , j, len1, len2;
    len1= StrLength(s1);
    len2= StrLength(s2);
    if  (len1+ len2>MAXSIZE-1)
           return  0 ;                      //s长度不够
    j=0;
    while(s1[j]!=’\0’) {
      s[i]=s1[j];
      i++;   j++;
	}
   j=0;
   while(s2[j]!=’\0’) {
       s[i]=s2[j];
       i++;    j++;
  }
  s[i]=’\0’;
  return 1;
}
```

**求子串**
```C
int StrSub (char *t, char *s, int i, int len){
     int slen;
     slen=StrLength(s);
     if ( i<1 || i>slen || len<0 || len>slen-i+1) {
          printf("参数不对");
          return 0;
      }
     for (j=0; j<len; j++)
           t[j]=s[i+j-1];
      t[j]=’\0’;
      return 1;
}
```

**串比较**
```C
int StrCmp(char *s1, char *s2){
	int i=0;
	while (s1[i]==s2[i] && s1[i]!=’\0’){
		i++;
	}
	return (s1[i]==s2[i]);
}
```


## 2.串的块链存储结构
### 2.1串的块链存储的表示
- 和线性表的链式存储结构相类似，也可采用链表方式存储串值

- 用一般链式存储结构也能实现串，但是对于一个结点，要存储一个字节大小的字符，需要另外花费占四个字节的指针来指示它，这样一个结点的存储密度只有可怜的$1/(1+4) = 0.2$

- 为了提高存储密度，我们让一个结点能存储多个字符，这样的一个结点，我们称之为**块(chunk)**

- 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上"#"或其他的非串值字符。

![[Pasted image 20260117014207.png]] 
### 2.2串块链存储的类型定义 
```C
#define CHUNKSIZE 80       //定义块的大小
typedef struct Chunk{
    char ch[CHUNKSIZE];      //数据域一次最大可以存储80个字节
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail;           //串的头指针和尾指针
    int curlen;                       //当前串的长度
}LinkString;
```



 
 
## 3.串的堆存储结构
### 3.1串堆存储的表示

- 在C 语言中，存在一个称之为＂堆＂的自由存储区，并由C语言的动态分配函数malloc() 和free() 来管理
![[Pasted image 20260117014829.png|400]]

- 利用函数malloc() ，根据每个串的长度，动态地为每个串在堆空间内申请相应大小的存储区域，将串顺序存储在所申请的堆内存区域中
- 这样我们就能以一组地址连续的存储单元存放字符串，串的空间在程序运行过程中**动态获取**，使用结束后，**归还堆空间**
- 字符串包括串名和串值两个部分，将一个串的串值存储为堆内存区域时，还需要在串名和堆内存位置之间建立对应关系，即串名的存储映像，也称为串的索引表

### 3.2串堆存储的类型定义

串堆存的类型定义
```C
typedef struct{
	char *p_ch;      //若串为空，则按照串长分配内存空间，否则指针null
	int length;        //记录串长
}HString;
```


索引表的类型定义
```C
typedef struct{
	char name[MAXNAME];  //串名
	int length;                       //串长
	char *start_ad               //串起始地址
}
```


## 4.串的模式匹配
- 串的模式匹配是指查找主串所含子串（模式串）第一次出现的位置
- 模式匹配算法有两种：BF（Brute-Force）算法和KMP(Knuth_Morris_Pratt)算法

为了方便演示，我们使用串的第一种定义方法
### 4.1BF算法——暴力检索所有的字符
- 将主串的第n个字符和模式串的第一个字符进行比较
- 若匹配，继续逐个比较后续字符
- 若不匹配则回溯，从主串的下一个字符开始，重新与模式串的第一个字符进行比较

*例如*：
我们有如下的主串"ababcabcacbab"，模式串为"abcac",其匹配过程为：

![[Pasted image 20260117021755.png|325]]
**代码实现**
```C
int Index_BF(SqString S,SqString T,int pos){
	int i = pos;
	int j = 1;
	while(i <= S.length && j <= T.length){
			if(S.ch[i] == T.ch[j]){
				i++;
				j++;
			}else{
				i = i - j + 2;           //匹配失败，回溯
				j = 1;
			}
	}
	if(j > T.length){
			return i-T.length;
	}else{
			return 0;
	}
}
```

**时间复杂度分析**：
我们设n为主串长度、m为模式串长度：
- 最好情况：每趟比较不成功都发生在第一次比较时，平均时间复杂度为O(m+n)
- 最坏情况：每趟比较不成功都发生在最后一次比较时，平均时间复杂度为O(m×n)
### 4.2KMP算法——利用已经部分匹配的结果而加快串的滑动
我们可以看到，使用BF算法进行匹配时，会进行大量重复的比较操作

例如上面的例子，从第三轮匹配中，当比较i=7，j=5不匹配时，下一轮比较又从i=4，j=1重新开始
然而，i=4、j=1和i=5、j=1以及i=6和j=1这3次比较都是不必进行的，因为我们从第三轮匹配中得知主串第4、5、6个字符必然是'b'、'c'、'a'(即模式串中第2、3、4个字符)

因为模式串中的第一个字符是a, 因此它无需再和这3个字符进行比较，而仅需将模式串向右滑动3 个字符的位置继续进行i=7 、j=2 时的字符比较即可

同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动两个字符的位置继续进行i=3 、j=1时的字符比较

注意到，在这种比较方式里**主串的i指针没有回溯**，永远朝一个方向移动
![[Pasted image 20260117022822.png|300]]

*现在我们推广到一般情况：*
我们假设主串为：$'s_1s_2...s_n'$，模式串为$'p_1p_2...p_m'$，从上面的分析可知，为了改进算法，需要解决下述问题：当匹配过程中产生“失配”（即$s_j≠p_j$) 时，主串中第i个字符(i 指针不回溯）应与模式串中哪个字符再比较？

假设我们已经进行了一些匹配操作，此时主串s正在与模式串p中第k(k<j) 个字符继续比较，则模式串中前k-1个字符的子串一定与主串对应的k-1长度的子串相匹配，(其中指针j指示的是子串开始的位置)：
$$'p_1p_2...p_{k-1}\ '='s_{i-k+1}s_{i-k+2}...s_{i-1}\ '$$

若模式串第K个字符匹配不上时，按照前面的设想，我们希望模式串向右滑动后，能跳过一些重复的对比，直接进行还没有进行的匹配
$$'p_{j-k+1}p_{j-k+2}...p_{j-1}\ '='s_{i-k+1}s_{i-k+2}...s_{i-1}\ '$$

由上面两个公式，推得下列等式：
$$'p_1p_2...p_{k-1}\ '='p_{j-k+1}p_{j-k+2}...p_{j-1}\ '$$

若模式串中存在满足这样一个公式的两个子串，则在匹配过程中，主串中第i个字符与模式串中第j个字符比较不等时，仅需将模式向右滑动至模式中第K个字符和主串中第i个字符对齐

此时，模式串中头k-1个字符的子串$'p_1p_2...p_{k-1}\ '$必定与主串中第i个字符之前长度为k-1的子串$'s_{i-k+1}s_{i-k+2}...s_{i-1}\ '$相等，由此，匹配仅需从模式串中第k个字符与主串中第i个字符比较起继续进行


由此，我们引出了几个概念：
- 前缀和后缀：对于字符串，如"abab"，其前缀是以第一个字符开始但不包含最后一个字符的所有子串：a, ab, aba；后缀是以最后一个字符结尾但不包含第一个字符的所有子串：b, ab, bab

- 最长相等前后缀：在相同的前缀和后缀中，最长的那个就是最长相等前后缀，比如字符串"*abab*c*abab*"，它的最长相等前后缀为"abab"

- 对于模式串T，我们记录其子串T\[1]~T\[j-1]的最长相等前后缀长度为k-1，并将k值记录到数组对应位置next\[j]中，其值的计算公式为：
$$
\text{next}[j] = \begin{cases}
0 &\text{当 } j=1 \\
\max\left\{ k \mid 1 < k < j,\, p_1...p_{k-1} == p_{j-k+1}...p_{j-1}\right\} & \text{当此集合非空时} \\
1 & \text{当不存在上面情况}\end{cases}
$$
我们根据next\[j]指示的位置，就能确定下一次模式串比较的位置，跳过重复的比较步骤

*例如*：
有模式串T"abcac"，其对应的next\[j]数组为：
 
| j        | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- |
| T\[j]    | a   | b   | a   | a   | b   | c   | a   | c   |
| next\[j] | 0   | 1   | 1   | 2   | 2   | 3   | 1   | 2   |
可以看到，j=1时，根据定义next\[1]=0；j=2、3、7时，不存在最长相等前后缀，所以next\[2]=1、next\[3]=1、next\[7]=1；j=4时，最长相等前后缀为1，即k-1=1，所以next\[4]=k=2，其余依次类推


获得next\[j]数组后，我们就能进行匹配了，具体做法如下：

- 当匹配过程中产生“失配”时，主串指针i不变，模式串指针j退回到next\[j\]所指示的位置上重进行比较，并且当指针j退至零时，指针i和指针j需同时增1
- 即若主串的第i个字符和模式串的第1个字符不等，应从主串的第i+1个字符起重新进行匹配

![[Pasted image 20260117031211.png|450]]

**代码实现**：
```C
void get_next(SqString T, int &next[]) {
	int i = 1;         // i 是当前正在计算 next[i] 的位置
	next[1] = 0;       // 初始条件：next[1] = 0
	int j = 0;         // j 代表最长相同前后缀的长度
	while (i <= T.length) { 
		if (j == 0 || T.ch[i] == T.ch[j]) { 
			++i;
			++j;
			next[i] = j;  // 记录最长前后缀的长度
		} else {  
			j = next[j];  // 回溯 j，寻找更短的前后缀
		}
	}
}
int Index_KMP(SqString S, SqString T, int pos) {
	int i = pos;  // 主串的索引，从 pos 开始匹配
	int j = 1;    // 模式串索引
	int next[MAX_SIZE]; // 存储 next 数组
	get_next(T, next);  // 计算 next 数组
			
	while (i <= S.length && j <= T.length) {
		if (j == 0 || S.ch[i] == T.ch[j]) {
			++i;
			++j;
		} else {
			j = next[j];
		}
}
	if (j > T.length) {
		return i - T.length;
	} else {
		return 0;
	}
}
```

**时间复杂度分析**
我们仍然设主串的长度为n，模式串的长度为m:
- 求next数组的时间复杂度为O(m)
- 算法整体最坏情况的时间复杂度为O(n\*m)，平均时间复杂度为O(n+m)


# 二、数组
## 1.数组的类型定义
### 1.1数组的属性
- 数组是按一定格式排列起来的，具有**相同元素**类型的数据元素的集合
- 一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组
	声明格式：数据类型 变量名称\[长度] 
	例如：int num\[5] = {0,1,2,3,4,5}
- 二维数组：若一维数组中的数据元素又是一维数组结构，则称它为二维数组
	声明格式：数据类型 变量名称\[行数]\[列数] 
	例如：int num\[3]\[3] = {{1,1,1},{2,2,2},{3,3,3}}
- 二维数组的逻辑结构：
	- 线性结构：每个数据元素是一个定长的线性表
	- 非线性定长的线性表结构：每个数据元素即在一个行表中，又在一个列表中 
### 1.2数组的特点
- 结构固定，一个数组定义后，维数和维界都不再改变
- 除了结构的初始化和销毁之外，一般只有取元素和修改元素的操作，不做插入和删除操作
- 对于一维数组的类型定义，和一般线性表类似，每个元素也只有一个直接前驱和直接后继。
- 对于多维数组，因为多维度的关系，就不只有一个直接前驱和直接后继。比如二维数组，有两个直接前驱和后继。

## 2.数组存储结构
因为数组的元素个数是确定的，因此很少采用链式结构，都采用顺序结构。虽然数组可以是多维度的，但是存储数据的内存单元是一维的。因此，在多维数组存储结构之前，需要解决**将多为关系映射到一维关系**的问题。
### 2.1顺序存储结构

#### 一维数组
- 有数组定义 int a\[5]，每个元素占有四个字节，假设a\[0]存储在第2000单元中，a\[3]的地址是多少？
	a\[0] 2000 ->a\[1] 2004->a\[2] 2008->a\[3] 2012
	LOC(i) = LOC(i-1)+L = (a+i)\*L  (i>0)`
	
	可以看到，一维数组和线性表存储方式一样，都是放在连续的存储空间中，每个元素占有的空间相等
#### 二维数组
- 可以看成是由若干个一维数组构成的；每一行都可以看作一维数组，每一列也都可以看作一维数组
- 用一维的存储单元来存放多维的数组，就要有约定的次序问题，有一个二维数组a\[n]\[m]
	- 以行序为主：LOC(i,j) = LOC(0,0) + (n\*i+j)\*L
	- 以列序为主：LOC(i,j) = LOC(0,0) + (m\*j+i)\*L

## 3.数组的操作

### 3.1特殊矩阵的压缩存储
#### 矩阵的存储
- 矩阵，就是一个由m\*n个元素排成的m行n列的表；
- 为了矩阵的常规存储，我们将它描述为一个二维数组；
- 矩阵常规存储的特点：
	- 可以对其元素进行随机存取；
	- 矩阵运算非常简单；
	- 存储密度为一；
- 不宜常规存储的矩阵：值相同的元素很多，且呈某种规律分布，零元素多，为了提高存储效率，我们引出了压缩存储
#### 压缩存储的特点
1. 什么是压缩存储：多个元素值相同，且只分配一个元素值得存储空间，且零元素不占存储空间；
2. 什么样的矩阵可以压缩存储：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵

#### 压缩存储的实现
-  对称矩阵：只存储上（或下）三角的数据元素，共占用n(n+1)/2个元素空间
	1. 以行序为主序将元素存放在一维数组b\[n(n+1)/2]中
	2. 其中b\[k] = a\[i]\[j] k=i\*n-i(i+1)/2+j
- 三角矩阵：只存储上（或下）三角的数据元素，对于另一半三角的相同元素，另外存储
	1. 以行序列为主序将元素存放在一维数组b\[n(n+1)/2+1]中
	2. 其中b\[k] = a\[i]\[j] k=(i-1)\*(2n-i+2)/2+j-i+1
- 带状矩阵：只存对角线附近的元素，其余为零的元素不存储
	1. 以行序为主序，用一维数组b\[n*(2k+1)] k为带宽存储所有非零元素，并映射到二维矩阵索引
	2. 将\b转换成二维数组，其中b\[i]\[j] = b\[i*(2k+1)+(j-i+k)]
- 稀疏矩阵：
	1. 三元组法：仅存储非零元素值及其行索引，列索引，使用一个3\*t的二维数组记录，其中t是非零元素的个数
	2. 压缩稀疏行：使用三个一维数组：values\[]存储所有非零元素，colIndex\[]存储对应列号，rowPtr\[]存储每一行第一个非零元素在values\[]的索引
	3. 十字链表法：使用链式存储，每个非零元素用一个结点进行存储，并且每个结点同时连接其所在行和列，每个结点存储：
		- 所在行，所在列
		- 该元素的值
		- 同一行的下一个非零元素的地址
		- 同一列的下一个非零元素的地址
对于这些操作，我们在以后的案例实现中来进行讲解

# 三、广义表
## 1.广义表的类型定义
### 1.1广义表的属性
- 广义表，又称列表（Lists），是由n(n>=0)个元素组成的有限序列，其中每一个ai可以是一个单一元素（原子），也可以是一个广义表（子表）
- 广义表通常记作：LS = (a1,a2,a3....an),其中LS为表名，n为表的长度，ai为表的元素
- 习惯上，一般用大写字母表示其广义表，小写字母表示原子
- 表头：若LS非空，则其第一个元素a1就是表头，记作head(LS) = a1，表头可以是原子，也可以是子表
- 表尾：除表头外的**其他元素组成的表**，记作tail(LS) = (a2,a3....an)
- 例如有：
	1. A=(),A为空表，长度为零
	2. B=(()),表长为1，表头表尾均为空表()
	3. C=(a,(b,c)) ，表长为2，由原子a和子表(b,c)构成，表头为a，表尾为((b,c))
	4. D=(x,y,z)，表长为3，表头x，表尾(y,z)
### 1.2广义表的性质
1. 广义表的数据元素有相对次序；有一个直接前驱和一个直接后继
2. 广义表的长度定义为最外层所包含的元素个数，即原子和子表都算作一个元素，如A=(a,(b,c))的长度为2
3. 广义表的深度定义为该广义表展开后所包含的括号的重数，如A=(b,c)的深度为1，B=(A,d)的深度为2，C=(f,B,h)的深度为3，原子深度为0，**空表深度为1**
4. 广义表可以与其他广义表共享，如B=(A)，在B中不必列出A的值，而是通过名称来引用
5. 广义表可以是一个递归的表，如：F=(a,F=(a,(a,(a...))))**递归表的深度是无限值，长度是有限值**
6. 广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，形成多层次的嵌套结构

## 2.广义表的存储结构
- 广义表的存储的底层还是线性表，但是可以存储不同类型的元素，可以是单个元素，也可以是表；广义表是线性表的推广，线性表是广义表的特例
- 为了实现数据类型的兼容，一般用链表结构进行存储
- 结构定义的代码实现：
	```C
	typedef struct List{
		int isAtom; //判断是不是原子，1表示原子，0表示子表
		union{
			char data; //原子数据
			struct List *subList; //子表指针
		};
		struct List *next; //指向下一个元素
	}List ,*GList;
	```
- 在某种前提下，它可以兼容线性表，数组，树和有向图等各种续航用的数据结构
- 当二维数组的每行或者每列作为子表来处理时，二维数组即为一个广义表
## 3.广义表的操作
1. 求表头GetHead(L)非空表的第一个元素，可以是一个原子，也可以是一个子表
	```C
	GList getHead(GList L){
		if(L == NULL) return NULL;
		return L;
	}
	```
2. 求表尾GetTail(L)非空表的去除表头元素以外其他元素所构成的表，表为尾一定是一个表
	```C
	GList getTail(GList L){
		if(L == NULL) return NULL;
		return L->next;
	}
	```
# 四、串、数组和广义表的对比

| 对比项  | 串（String）            | 数组（Array）                     | 广义表（List）                |
| ---- | -------------------- | ----------------------------- | ------------------------ |
| 定义   | 由字符串组成的线性结构，以`\0`为结尾 | 一组**相同类型**的数据，存储在连续内存中        | 由元素组成的线性表，元素可以是原子，也可以是子表 |
| 数据类型 | 仅包含字符类型`char`        | 仅包含相同的数据类型，可以是基本类型，也可以是抽象数据类型 | 可以包含不同类型的数据，可以嵌套         |
| 存储结构 | 顺序存储                 | 顺序存储                          | 链式存储                     |
| 表长度  | 一般固定                 | 一般固定                          | 动态变化                     |
| 存取方式 | 通过索引访问               | 通过索引访问                        | 遍历查找元素                   |
| 适用操作 | 拼接，分隔，匹配，查找          | 插入，删除，查找，遍历                   | 插入，删除，遍历递归               |
