---

author: Fang
date: 2025-03-12
tags:
---
在上一节，我们学习了线性表，相信你已经对**线性结构**这一基础概念有了清晰的理解

线性表的一个显著特点是：**插入和删除可以发生在任意位置**，结构灵活、操作自由，适合处理需要频繁修改的线性数据

然而在实际开发中，我们经常会遇到这样一些情况：
- 浏览器的前进/后退功能，只能一步一步地返回上一步操作；
- 操作系统处理任务时，先到的任务应该先处理，后来的任务排队等待；
- 表达式求值、函数调用等也都有明确的“处理顺序

这时候我们就不再需要“自由的插入删除”，而更关注**操作顺序的限制**；于是，**两种特殊的线性表**应运而生：**栈（Stack）和队列（Queue）**

它们的“特殊”之处就在于：
- 栈：只允许在表尾（栈顶）进行插入和删除，遵循后进先出的原则；
- 队列：只允许在表尾（队尾）插入、在表头（对头）删除，遵循先进先出的原则

虽然操作看起来受限，但正因为这些限制，它们在许多关键场景中**更加高效、简洁**，也是我们接下来要学习的重要内容

# 一、栈的逻辑结构
## 1.栈的定义和相关概念
- **栈是限定仅在一端进行元素插入和删除的线性表**。
- 最后进入的元素会第一个出去，也就是后进先出，简称*LIFO*（Last In First Out）。
- 允许插入和删除的一端称为**栈顶**，用栈顶指针指向；不允许插入和删除的一端称为**栈底**。
- 表中没有元素时称为空栈。
- 栈的插入操作称为进栈、压栈或入栈。栈的删除操作称为退栈或出栈。

*思考题*：已知有三个元素a,b,c，入栈顺序是abc，它们出栈的顺序可能有几种？

| 栈的操作过程                                 | 出栈顺序 |
| -------------------------------------- | ---- |
| a入栈 -> a出栈 -> b入栈 -> b出栈 -> c入栈 -> c出栈 | abc  |
| a入栈 -> a出栈 -> b入栈 -> c入栈 -> c出栈 -> b出栈 | acb  |
| a入栈 -> b入栈 -> b出栈 -> a出栈 -> c入栈 -> c出栈 | bac  |
| a入栈 -> b入栈 -> b出栈 -> c入栈 -> c出栈 -> a出栈 | bca  |
| a入栈 -> b入栈 -> c入栈 -> c出栈 -> b出栈 -> a出栈 | cba  |

*有没有cab的出栈顺序呢*？
因为c第一个出栈，那a和b已经入栈，则a和b出栈的顺序只能是ba，*所以不可能有cab的顺序*



>栈本身就是一种特殊的线性表，因此也有顺序存储和链式存储两种存储方式
  栈的顺序存储叫做**顺序栈**；栈的链式存储叫做**链栈**。

# 二、栈的顺序存储结构——顺序栈
## 1.栈顺序存储的表示
- 同顺序表存储结构相同，即**用一组地址连续的存储单元**依次存放自栈底到栈顶的数据元素，栈底一般在低地址端。
- 另外，我们为了方便对元素的定位和操作，引入以下变量：
	- int类型的指针变量top，指示栈顶元素的位置；
	- int类型的指针变量base，指示栈底元素的位置；
	- int类型的变量stacksize，表示栈可使用的最大容量。
![[Pasted image 20250311163750.png|250]]

>为了方便操作，top指针真正指示的是栈顶元素上面的一节存储位置的地址；就像一个盖子压在栈顶上面

**顺序栈状态判断**
- 若为空栈，则有：base == top。
- 若有元素入栈，top指针就上移；若有元素出栈，top指针就下移。
- 若栈满，则有top - base == stacksize。
- 栈的溢出：
	- 上溢：栈已满，又要压入元素；是一种错误，使内存溢出程序报错；
	- 下溢：栈已经空了，还要弹出元素；一般认为是一种结束条件，问题处理结束。

## 2.栈顺序存储的类型定义
与顺序表的实现一样，只是需要额外增加两个指针指示栈顶栈尾。
```C
#define MAXSIZE  100
typedef int SElemType; 
typedef  struct {
    DataType  data[MAXSIZE];
    SElemType *top;
    SElemType *base;
 }SeqStack, *PSeqStack;
```

## 3.栈顺序存储基本操作的实现
**顺序栈的初始化**
```C
Status InitStack(SqStack *S){
	S->base = (SElemType*)malloc(MAXSIZE * sizeof(SElemType)); 
	if(!S->base){
		printf("内存分配失败");
		return ERROR;
	}
	S->top = S->base;
	S->stacksize = MAXSIZE;
	return OK;
	}
```

**判断顺序栈是否为空**
```C
Status StackEmpty(Sqstack S){
	if(S.top == S.base){
		return TRUE;
	}else{
		return FALSE;
	}
}
```

**求栈中元素的个数**
```C
int StackLength(SqStack S){
	return S.top - S.base;
}
```

**清空顺序表**
```C
Status ClearStack(SqStack *S){
	if(S->base){
		S->top = S->base;
		return OK;
	}else{
		prinf("顺序栈不存在")
		return ERROR;
	}
}
```

**销毁顺序栈**
```C
Status DestoryStack(SqStack *S){
	if(S->base){
		free(S->base); //释放base对应内存
		S->stacksize = 0;
		S->base = S->top = NULL; //避免野指针风险
		return OK;
	}
}
```

>野指针，是指指向的内存区域已经被释放或者未被正确初始化的指针；简单来说，就是指针指向的地方已经不是我们期望它指向的有效内存区域了。

**顺序栈入栈**
```C
Status Push(SqStack *S,SElemType e){
	if(S->top - S->base == S->stacksize){
		return ERROR;
	}
	*(S->top) ++= e;                     
	return OK; 
}
```

在这里`*(S->top) ++ = e`是核心语句，可以等效成以下语句：

```C++
*(S->top) = e;
S->top ++;
```

这里，`*`是指针取值操作，将top指向的值改为入栈元素`e`；在C语言中，`++`的优先级比`*`高，top指针会先上移；再进行赋值操作；
 但是原语句`S->top++`是后置递增，会把递增之前的值返回，交给`*`处理，也就实现了现有元素入栈的效果。

**顺序栈的出栈**
```C++
Status Pop(SqStack *S,SElemType *e){
	if(S->top == S->base){
		return ERROR;
	}
	*e = *--(S->top);
	return OK;
}
```

与入栈的核心语句类似，对于`*e = *--(S->top)`，等效于以下语句：

```C++
--S->top;
*e = *S->top;
```

语句`--S->top`是前置递减，会返回递减后的top指针；因为top指针指向的是栈顶的上一个存储位置，所以我们使用前置递减，再对top指针进行取值操作。

# 二、栈的链式存储结构——链栈
## 1.栈的链式存储的表示
- 链栈的底层存储结构是**单链表**，它通过动态分配内存实现栈结构。
- 我们将链表的**头部**作为栈顶，每次栈的插入和删除操作都发生在链表的头部，为了简化实现，**不设置头结点**。
- 栈顶指针 `S` 直接指向链表的第一个**有效结点**（即当前栈顶元素）；节点的指针指向**自上而下**，即从最新入栈的元素（栈顶）向最早入栈的元素（栈底）方向连接。

![[Pasted image 20250312185959.png|290]]


**链栈状态的判定**
- 链栈的存储结构使其具有良好的动态扩展能力，不需要预先设定栈的大小，因此**基本不存在栈满的问题**，仅当系统内存耗尽时才可能“上溢”。
- 当链栈为空时，`S == NULL`，表示没有任何元素。

## 2.栈链式存储的类型定义
```C
typedef struct StackNode{
	SElemType int;
	struct StackNode *next;
}StackNode, *LinkStack;
```
## 3.栈链式存储基本操作的实现

**链栈的初始化**
```C
Status InitStack(LinkStack *S){
	*S = NULL; //栈顶指针为空
	return OK;
}
```

**判断链栈是否为空**
```C
Status StackEmpty(LinkStack S){
	if(S == NULL){
		return TRUE;
	}else{
		return FALSE;
	}
}
```

**入栈操作**
```C
Status Push(LinkStack *S, SElemType e) {
	   // 动态分配新结点
    StackNode *p = (StackNode*)malloc(sizeof(StackNode));  

    if (!p) {  // 内存分配失败
        return ERROR;  // 返回错误码（假设 ERROR 已定义）
    }
    p->data = e;      // 存入数据
    p->next = *S;     // 新结点指向原栈顶
    *S = p;           // 更新栈顶指针
    return OK;        // 返回成功码
}
```

**出栈操作**
```C
Status Pop(LinkStack *S, SElemType *e) {
    if (*S == NULL) {  // 栈空，无法弹出
        return ERROR;  // 返回错误码（假设 ERROR 已定义）
    }
    StackNode *p = *S;  // 暂存当前栈顶结点
    *e = p->data;       // 通过指针 e 返回栈顶元素
    *S = p->next;       // 修改栈顶指针，指向下一个结点
    free(p);            // 释放原栈顶结点
    return OK;          // 返回成功码
}
	```

**取栈顶元素**
因为链栈的头指针直接指向栈顶，直接取指针指向结点的数据域就行了
```C
SElemType GetTop(LinkStack S) {
    if (S == NULL) {
        // 栈为空，可以返回一个默认值，或者用错误处理机制
        // 这里假设 SElemType 是 int，返回 0 表示错误
        return 0;
    }
    return S->data;  // 栈非空，返回栈顶元素
}
```

# 四、栈的总结
| **类别**      | **顺序栈**                                    | **链栈（链式存储结构）**                               |
| ----------- | ------------------------------------------ | -------------------------------------------- |
| **存储结构**    | 用连续的内存空间（数组）存储，栈底在低地址，栈顶指针指向栈顶元素上方位置       | 用链表存储，栈顶指针指向链表头结点，节点通过指针连接形成栈结构              |
| **空间利用**    | 预先分配固定大小空间，空间利用率受限，可能发生栈满（上溢）              | 动态分配内存，空间利用灵活，基本不存在栈满，只有内存耗尽才溢出              |
| **访问方式**    | 通过指针直接访问栈顶元素，访问速度快                         | 访问栈顶元素需通过指针访问，速度稍慢，但依然高效                     |
| **入栈/出栈效率** | 入栈和出栈操作简单，时间复杂度O(1)                        | 入栈和出栈操作在链表头部完成，时间复杂度O(1)                     |
| **内存管理**    | 需要连续内存空间，扩容复杂，可能导致内存搬移                     | 动态分配每个节点，内存管理灵活，无需整体搬移                       |
| **实现复杂度**   | 实现简单，指针运算直接，适合固定大小栈                        | 实现稍复杂，需要动态分配和释放节点，注意内存管理                     |
| **优点**      | 1. 访问速度快  <br>2. 实现简单  <br>3. 适合大小固定的栈     | 1. 动态空间分配，灵活  <br>2. 无栈满限制  <br>3. 适合大小不确定的栈 |
| **缺点**      | 1. 空间固定，可能浪费或溢出  <br>2. 需要连续内存空间           | 1. 需要额外指针空间，存储密度低  <br>2. 实现复杂，内存管理需谨慎       |
| **适用场景**    | 1. 栈大小已知且固定  <br>2. 访问速度要求高  <br>3. 内存连续可用 | 1. 栈大小动态变化  <br>2. 内存碎片较多，无法保证连续空间           |
# 五、栈的应用

## 1.进制转换
**问题描述**
十进制数N和其他d进制数的转换是计算机实现计算的基本问题，其解决方法很多，其中一个简单算法基于下列原理：
$$N = (N\ div\ d)*d+N\ mod \ d$$
具体算法步骤如下：
1. 用进制数d除以十进制整数N，记录余数
2. 将商继续除以d，并记录余数
3. 重复上述过程，直到商为零

例如：$(1348)_{10}=(2504)_{8}$，其算法流程如下：

| 除数N  | 商(N div 8) | 余数(N mod 8) |
| ---- | ---------- | ----------- |
| 1348 | 168        | 4           |
| 168  | 21         | 0           |
| 21   | 2          | 5           |
| 2    | 0          | 2           |
**问题分析**
上述计算过程中，**余数是按从低位到高位的顺序产生的，而输出时需要从高位到低位打印**；两者顺序相反，直接输出会导致结果错误
为解决此问题，可以利用栈的“先进后出”特性：将计算过程中得到的各位余数依次入栈，最后通过出栈顺序打印，即可实现从高位到低位的正确输出

**代码实现**
```C
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 100
#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int Status;
typedef int SElemType;

typedef struct {
    SElemType *base;
    SElemType *top;
    int stacksize;
} SqStack;

// 初始化栈
Status InitStack(SqStack *S) {
    S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));
    if (!S->base) {
        printf("内存分配失败\n");
        return ERROR;
    }
    S->top = S->base;
    S->stacksize = MAXSIZE;
    return OK;
}

// 销毁栈
void DestoryStack(SqStack *S) {
    if (S->base) {
        free(S->base);
        S->base = S->top = NULL;
        S->stacksize = 0;
    }
}

// 判断栈是否为空
Status IsEmpty(SqStack S) {
    return S.top == S.base ? TRUE : FALSE;
}

// 判断栈是否为满
Status IsFull(SqStack S) {
    return (S.top - S.base == S.stacksize) ? TRUE : FALSE;
}

// 入栈操作
Status Push(SqStack *S, SElemType e) {
    if (IsFull(*S)) {
        printf("栈已满，无法入栈\n");
        return ERROR;
    }
    *(S->top++) = e;
    return OK;
}

// 出栈操作
Status Pop(SqStack *S, SElemType *e) {
    if (IsEmpty(*S)) {
        printf("栈为空，无法出栈\n");
        return ERROR;
    }
    *e = *(--S->top);
    return OK;
}

// 查看栈顶元素
Status Peek(SqStack S, SElemType *e) {
    if (IsEmpty(S)) {
        printf("栈已空\n");
        return ERROR;
    }
    *e = *(S.top - 1);
    return OK;
}

// 将十进制转换成对应进制
Status DecimalToBase(int n, int base) {
    if (n == 0) {
        printf("0\n");
        return OK;
    }

	//我们根据余数取出字符串对应位置的字符
	//注意转换成16进制后：10-A;11-B;12-C....依次类推
    char digits[] = "0123456789ABCDEF";
    SqStack S;

    if (!InitStack(&S)) {
        printf("初始化失败\n");
        return ERROR;
    }

    // 进栈
    while (n > 0) {
        int remainder = n % base;
        if (!Push(&S, remainder)) {
            DestoryStack(&S);
            printf("入栈失败，栈已销毁\n");
            return ERROR;
        }
        n /= base;
    }

    // 出栈
    SElemType value;
    while (!IsEmpty(S)) {
        if (!Pop(&S, &value)) {
            DestoryStack(&S);
            printf("出栈失败\n");
            return ERROR;
        }
        printf("%c", digits[value]);
    }
    
    printf("\n");
    DestoryStack(&S);
    return OK;
}

int main() {
    int decimal_number = 255;

    printf("十进制数 %d 转换为二进制: ", decimal_number);
    DecimalToBase(decimal_number, 2);

    printf("十进制数 %d 转换为八进制: ", decimal_number);
    DecimalToBase(decimal_number, 8);

    printf("十进制数 %d 转换为十六进制: ", decimal_number);
    DecimalToBase(decimal_number, 16);

    return 0;
}
```

## 2.括号匹配验证

**问题描述**
给定一个只包含三种括号字符 `{}`, `[]`, `()` 的字符串，判断其中的括号是否正确嵌套和匹配。

**问题分析**
括号的正确匹配遵循“后进先出”的原则，最内层的左括号必须先与对应的右括号匹配，最外层的左括号对应最外层的右括号。利用栈结构可以高效地实现这一逻辑。

**具体操作步骤**
1. 从左到右遍历字符串中的每个字符。
2. 遇到左括号 `{`、`[`、`(` 时，将其压入栈中。
3. 遇到右括号 `}`、`]`、`)` 时，检查栈是否为空：
    - 如果栈为空，说明当前右括号没有对应的左括号，匹配失败。  
    - 如果栈不为空，弹出栈顶的左括号，判断是否与当前右括号成对匹配；不匹配则失败。     
4. 遍历结束后，若栈为空，说明所有括号均正确匹配；若栈非空，说明存在多余的左括号，匹配失败。
    


**代码实现**
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXSIZE 100
#define TRUE 1
#define FALSE 0

typedef char SElemType;

typedef int Status;

typedef struct {
    SElemType *base;
    SElemType *top;
    int stacksize;
} SqStack;

// 初始化栈
Status InitStack(SqStack *S) {
    S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));
    if (!S->base) {
        printf("内存分配失败\n");
        return FALSE;
    }
    S->top = S->base;
    S->stacksize = MAXSIZE;
    return TRUE;
}

// 销毁栈
Status DestroyStack(SqStack *S) {
    if (S->base) {
        free(S->base);
        S->base = S->top = NULL;
        S->stacksize = 0;
        return TRUE;
    }
    return FALSE;
}

// 判断栈是否为空
Status IsEmpty(SqStack S) {
    return (S.top == S.base) ? TRUE : FALSE;
}

// 判断栈是否满
Status IsFull(SqStack S) {
    return (S.top - S.base == S.stacksize) ? TRUE : FALSE;
}

// 入栈
Status Push(SqStack *S, SElemType e) {
    if (IsFull(*S)) {
        printf("栈已满，无法入栈\n");
        return FALSE;
    }
    *(S->top++) = e;
    return TRUE;
}

// 出栈
Status Pop(SqStack *S, SElemType *e) {
    if (IsEmpty(*S)) {
        printf("栈已空\n");
        return FALSE;
    }
    *e = *(--S->top);
    return TRUE;
}

// 括号匹配函数
Status BracketMatched(char *expr) {
    SqStack S;
    if (!InitStack(&S)) {
        return FALSE;
    }
    for (int i = 0; expr[i] != '\0'; i++) {
        char ch = expr[i];
        // 左括号入栈
        if (ch == '(' || ch == '{' || ch == '[') {
            Push(&S, ch);
        }
        // 遇到右括号就检查栈是否为空并匹配
        else if (ch == ')' || ch == '}' || ch == ']') {
            if (IsEmpty(S)) {
                DestroyStack(&S);
                printf("括号匹配失败：遇到右括号但栈为空\n");
                return FALSE;
            }
            char top;
            Pop(&S, &top);
            // 判断是否匹配
            if ((ch == ')' && top != '(') ||
                (ch == '}' && top != '{') ||
                (ch == ']' && top != '[')) {
                DestroyStack(&S);
                printf("括号匹配失败：括号不匹配\n");
                return FALSE;
            }
        }
        // 其他字符忽略
    }
    int result = IsEmpty(S);
    DestroyStack(&S);
    if (result) {
        printf("括号匹配成功\n");
        return TRUE;
    } else {
        printf("括号匹配失败：左括号多余\n");
        return FALSE;
    }
}

int main() {
    //测试括号匹配 
    char expr[100] = "{[()()]]}"; 
    printf("测试表达式：%s\n", expr);

    BracketMatched(expr);
    return 0;
}
```

## 3.表达式求值

**问题描述**
实现一个程序，接收包含简单四则运算（加、减、乘、除）和括号的表达式字符串（例如：`3+5/5*6+7=`），并计算其最终结果。

**问题分析**
表达式求值是计算机科学中的一个经典问题。我们采用“算符优先算法”来实现，该算法通过比较运算符的优先级来确定运算顺序。

表达式的组成部分可归纳为：
- **操作数 (Operand)**：数字（常量或变量）；
- **运算符 (Operator)**：算术运算符 +, -, ×, /；
- **界限符 (Delimiter)**：括号()和表达式结束符=  。

为了实现表达式求值，我们需要维护两个栈：
1. **操作符栈 (OPTR)**：用于存储待处理的运算符。
2. **操作数栈 (OPND)**：用于存储操作数和中间计算结果。
    

**算法处理**
算法核心是自左向右扫描表达式，并根据当前字符和栈顶操作符的优先级进行处理：
1. 遇到数字：直接压入操作数栈（OPND）。

2. 遇到运算符（+、-、×、/）：
    - 比较当前运算符和操作符栈（OPTR）栈顶运算符的优先级。
    - 如果当前运算符优先级高，直接压入操作符栈。
    - 如果当前运算符优先级低或相等，弹出栈顶运算符，弹出两个操作数，计算后将结果压入操作数栈，重复比较直到当前运算符优先级高或栈空，再将当前运算符压入栈。
        
3. 遇到左括号 (：直接压入操作符栈。
4. 遇到右括号 )：不断弹出操作符并计算，直到弹出对应的左括号为止。
5. 遇到表达式结束符 =：不断弹出操作符并计算，直到操作符栈为空。
6. 结束时：操作数栈中剩下的唯一值即为表达式结果。


**算法流程举例** 
例子：计算表达式12 + 3 × 4 - 6 / 2 = 

| 步骤  | 扫描字符  | 判断情况                           | 操作                                                      | 操作数栈 (OPND) | 运算符栈 (OPTR) |
| --- | ----- | ------------------------------ | ------------------------------------------------------- | ----------- | ----------- |
| 1   | 12    | 为操作数，直接入栈                      | 操作数12压入OPND                                             | [12]        | []          |
| 2   | +     | 运算符栈为空，+直接入栈                   | 运算符+入栈                                                  | [12]        | [+]         |
| 3   | 3     | 为操作数，直接入栈                      | 操作数3压入OPND                                              | [12、3]      | [+]         |
| 4   | ×     | 运算符×的优先级高于+                    | ×压入OPTR                                                 | [12、3]      | [+, ×]      |
| 5   | 4     | 为操作数，直接入栈                      | 操作数4压入OPND                                              | [12、3、4]    | [+, ×]      |
| 6   | -     | 运算符 -的优先级低于OPTR栈顶的 ×，需要先处理栈顶的× | 从OPND弹出两个操作数：4 和 3，从OPTR弹出×，计算 3 × 4 = 12，结果压入OPND      | [12、12]     | [+]         |
| 7   | -     | 运算符 - 的优先级等于OPTR栈顶的+，继续处理栈顶的 + | 从OPND弹出两个操作数：12 和 12，从OPTR弹出 +，计算 12 + 12 = 24，结果压入OPND | [24]        | []          |
| 8   | -     | 运算符栈为空，-直接入栈                   | -压入OPTR                                                 | [24]        | [-]         |
| 9   | 6     | 为操作数，直接入栈                      | 操作数6压入OPND                                              | [24、6]      | [-]         |
| 10  | /     | /优先级高于-                        | /压入OPTR                                                 | [24、6]      | [-, /]      |
| 11  | 2     | 为操作数，直接入栈                      | 操作数2压入OPND                                              | [24、6、2]    | [-, /]      |
| 12  | =（结束） | 不断弹出操作符并计算，直到操作符栈为空            | 将6、2和/出栈，计算结果为3                                         | [24、3]      | [-]         |
| 13  |       |                                | 两个栈继续弹出元素，计算24-3=21，结果入栈                                | [21]        | []          |

**代码实现**
```C
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAXSIZE 100
#define TRUE 1
#define FALSE 0

typedef char SElemType;
typedef int Status;

typedef struct {
    SElemType *base;
    SElemType *top;
    int stacksize;
} SqStack;

// 初始化栈
Status InitStack(SqStack *S) {
    S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));
    if (!S->base) {
        printf("内存分配失败\n");
        return FALSE;
    }
    S->top = S->base;
    S->stacksize = MAXSIZE;
    return TRUE;
}

// 销毁栈
Status DestroyStack(SqStack *S) {
    if (S->base) {
        free(S->base);
        S->base = S->top = NULL;
        S->stacksize = 0;
        return TRUE;
    }
    return FALSE;
}

// 判断栈是否为空
Status IsEmpty(SqStack S) {
    return (S.top == S.base) ? TRUE : FALSE;
}

// 判断栈是否满
Status IsFull(SqStack S) {
    return (S.top - S.base == S.stacksize) ? TRUE : FALSE;
}

// 入栈
Status Push(SqStack *S, SElemType e) {
    if (IsFull(*S)) {
        printf("栈已满，无法入栈\n");
        return FALSE;
    }
    *(S->top++) = e;
    return TRUE;
}

// 出栈
Status Pop(SqStack *S, SElemType *e) {
    if (IsEmpty(*S)) {
        printf("栈已空\n");
        return FALSE;
    }
    *e = *(--S->top);
    return TRUE;
}

// 获取栈顶元素
SElemType GetTop(SqStack S) {
    if (IsEmpty(S)) return '\0';
    return *(S.top - 1);
}

// 运算符优先级
int Priority(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '(') return 0; // '(' 优先级最低
    return -1;
}

// 计算两个操作数和运算符的结果
int Calculate(int a, int b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/':
            if (b == 0) {
                printf("错误：除数不能为0！\n");
                exit(EXIT_FAILURE);
            }
            return a / b;
        default: return 0;
    }
}

// 表达式求值
int EvalExpression(const char *expr) {
    SqStack optr;               // 运算符栈
    int operands[MAXSIZE];      // 操作数栈（数组模拟）
    int topOperand = -1;        // 操作数栈顶指针

    InitStack(&optr);
    Push(&optr, '#');           // 结束符，方便判断

    const char *p = expr;
    while (*p != '\0') {
        if (isdigit(*p)) {
            // 读取多位数字
            int num = 0;
            while (isdigit(*p)) {
                num = num * 10 + (*p - '0');
                p++;
            }
            operands[++topOperand] = num; // 数字入操作数栈
        } else {
            char topOp = GetTop(optr);
            if (*p == '(') {
                Push(&optr, *p); // '(' 入栈
                p++;
            } else if (*p == ')') {
                // 遇到 ')'，弹出并计算直到遇到 '('
                while (topOp != '(') {
                    int b = operands[topOperand--];
                    int a = operands[topOperand--];
                    char op;
                    Pop(&optr, &op);
                    operands[++topOperand] = Calculate(a, b, op);
                    topOp = GetTop(optr);
                }
                char temp;
                Pop(&optr, &temp); // 弹出 '('
                p++;
            } else if (*p == '+' || *p == '-' || *p == '*' || *p == '/' || *p == '#' || *p == '=') {
                if (*p == '=') *p = '#'; // 统一结束符

                // 栈顶运算符优先级高或等于当前运算符，先计算
                while (topOp != '#' && Priority(topOp) >= Priority(*p)) {
                    int b = operands[topOperand--];
                    int a = operands[topOperand--];
                    char op;
                    Pop(&optr, &op);
                    operands[++topOperand] = Calculate(a, b, op);
                    topOp = GetTop(optr);
                }
                if (*p == '#') break; // 结束
                Push(&optr, *p);      // 当前运算符入栈
                p++;
            } else if (*p == ' ') {
                p++; // 跳过空格
            } else {
                printf("非法字符：%c\n", *p);
                exit(EXIT_FAILURE);
            }
        }
    }

    if (topOperand != 0) {
        printf("表达式错误\n");
        exit(EXIT_FAILURE);
    }

    DestroyStack(&optr);
    return operands[topOperand];
}

int main() {
    char expr[MAXSIZE];
    printf("请输入表达式（以=结束，例如 3+5*(2-1)=）：");
    fgets(expr, MAXSIZE, stdin);

    // 去除换行符
    for (int i = 0; i < MAXSIZE; i++) {
        if (expr[i] == '\n') {
            expr[i] = '\0';
            break;
        }
    }

    int result = EvalExpression(expr);
    printf("计算结果：%d\n", result);
    return 0;
}
```

本节，我们来学习队列这种数据结构。
# 一、队列的逻辑结构
## 1.队列的定义和相关概念
- 队列是一种先进先出（*First In First Out*），**FIFO结构**的线性表，在表的一端——队尾插入，在表的另一端——队头删除。
- 表中没有元素时称为空队列。
- 队列的插入操作称为进队列或入队列。队列的删除操作称为退队列或出队列。


>作为线性表，队列的存储结构也分为两种——用顺序存储实现的叫做**顺序队**；用链式存储实现的叫做**链队列**。
# 二、队列的顺序存储结构——顺序队
## 1.队列顺序存储的表示
- 顺序队使用了顺序表进行元素的存储，即利用一组地址连续的存储单元依次存放从队头到队尾的数据元素。
- 为了表示表中元素下标的位置，我们另外设置了两个变量：
	- int型变量front，指向队头元素的位置，称为头指针；
	- int型变量rear，指向队尾元素的后一个位置，称为尾指针，这和栈顶top指针的思想一致。

>注意，这里的头指针和尾指针只是一种简称，其实质上只是指示队列元素位置的整型变量。

![[Pasted image 20250710011933.png]]

**顺序队状态判断**
- 队列初始化，顺序队内没有元素，头指针和尾指针都为零。
- 若有元素入队，则将插入元素赋值给尾指针rear对应的存储地址，尾指针后移。
- 若有元素出队，则将头指针对应存储地址的元素赋值给出队元素，将头指针后移。
- 若头指针和尾指针相等（不一定为零），则队列为空。

>关于顺序队列的溢出状态的判断，我们在后面重点讨论。

## 2.队顺序存储的类型定义
```C
#define MAXQSIZE 100
Typedef struct {
	QElemType *base;          //初始化的动态分配存储空间
	int front;                        //头指针，若队列不空，指向队列头元素
	int rear;                         //尾指针，若队列不空，指向队列尾元素的下一个位置
}SqQuene;
```

## 3.顺序队的溢出状态——真溢出与假溢出

- 我们知道顺序队的存储空间是有限的，当元素个数大于最大承受数，不能再入队，也就是**真溢出**。
- 在顺序队入队、出队的过程中，由于头指针、尾指针的向后移动，有可能出现尾指针指向队列的尾端，但是队列中仍有空闲的空间，这种情况叫**假溢出**。
- 若`front = 0;rear = MAXQSIZE`，则说明顺序队中不能再塞入元素，不能再入队，为**真溢出**。
- 若`front != 0;rear = MAXQSIZE`，虽然顺序队中不能再塞入元素，但是队中还有剩余空间，为**假溢出**。

*由于顺序对的假溢出，使得队列中尽管存在空闲空间，但是我们却不能存入元素，这就导致了存储空间的浪费，有什么解决办法呢？*
## 4.解决假上溢的方法——循环队列

- 我们可以将队空间**设想成一个循环的表**，即分配给队列的m个存储单元可以循环使用。
- 在插入元素时，若rear == MAXQSIZE，且顺序队的队头空间还空着，则使尾指针回到队的起始位置继续存储元素。
- 本质上，队列的存储空间还是线性结构，但是我们通过头尾指针将头尾连在了一起，达成了循环的效果。
![[Pasted image 20260102202414.png|675]]


*但是对于这种方式，队空和队满时都满足front == rear，那该怎么判断是否队满呢？*

- 另设一个变量num，记录元素个数,若num == MAXQSIZE 则队满。
- 牺牲掉一个空间元素，我们约定以**队列头指针在队列尾指针的下一位**
	**置上作为队满的标志**，也就是`(rear + 1) % MAZQSIZE == front ? 1:0`
- 于此同时，判断队空的条件仍然是front == rear

## 5.队列顺序存储基本操作的实现
在这里，我们使用循环队列来介绍

**顺序队的初始化**
```C
Status Init(SqQuene *Q){
	Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
	if(!Q->base){
		cout<<"内存分配失败"<<endl;
		return ERROR;
	}
	Q->front = Q->rear = 0; //头尾指针置为零,从队头开始
	return OK;
}
```

**求队列的长度**
```C
int QueueLength(SqQuene Q){
	return ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);
}
```


*算法详解*
在循环队列中，计算队列当前长度时，front 和 rear指针的位置关系决定了计算方式：
1. 当 rear >= front 时，队列长度可以直接用：
$$Q.rear−Q.front$$
	这是因为队尾指针在队头指针的后面，直接相减即可得到元素个数。 

2. 当 rear < front 时，头指针在尾指针后面，队列长度计算为：

$$MAXQSIZE−(Q.front−Q.rear)=Q.rear−Q.front+MAXQSIZE$$

3. 统一公式，将两种情况合并，使用**取模运算**实现统一计算：

$$length=(Q.rear−Q.front+MAXQSIZE)mod  MAXQSIZE$$

**公式的合理性分析**
- 当 Q.rear >= Q.front时，(Q.rear - Q.front + MAXQSIZE) 的结果一定大于MAXQSIZE而小于MAXQSIZE的二倍，对MAXQSIZE取模后，结果就是 Q.rear -Q.front。
- 当Q.rear < Q.front时，(Q.rear - Q.front + MAXQSIZE)的结果就是队列的实际长度，且小于MAXQSIZE，对MAXQSIZE取模后结果不变。

**循环队列入队**
```C
Status EnQueue(SqQueue *Q, QElemType e) {
    if ((Q->rear + 1) % MAXQSIZE == Q->front) {
        return ERROR;
    }
    Q->base[Q->rear] = e;              // 新元素加入队尾
    Q->rear = (Q->rear + 1) % MAXQSIZE; // 队尾指针循环后移
    return OK;                          // 返回成功状态
}
```

**循环队列出队**
```C
Status DeQueue(SqQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) {
        return ERROR;  // 队列为空，出队失败
    }
    *e = Q->base[Q->front];              // 保存队头元素到指针 e 指向的内存
    Q->front = (Q->front + 1) % MAXQSIZE; // 头指针循环后移
    return OK;                           // 返回成功状态
}
```
**取队头元素**
```C++
SElemType GetHead(SqQuene Q){
	if(Q.front = Q.rear){
		return Q.base[Q.front];
	}
}
```

# 三、队列的链式存储结构——链队列

## 1.队列链式存储的表示
链队的底层结构是用链表实现的，但是在链表的基础上，还添加了两个指针（**注意这里的头尾指针是真指针**），头指针和尾指针来指示头尾元素位置
链队为空，就是头指针和尾指针都指向一个空结点
![[Pasted image 20250710014231.png]]
## 2.队列链式存储的的类型定义
在这里我们先定义了链队列的结点结构，再定义链队列的两个指针，让指针指向结点，构建起链队列的基本结构。
```C
#define MAXQSIZE 100;
//定义链队中的结点
typedef struct Qnode{
	QElemType data;
	struct Qnode *next;
}QNode,*QueuePtr;

//定义链队的指针结构
typedef struct{
	QuenePtr front;
	QuenePtr rear;
}LinkQueue;
```
## 3.队列链式存储基础操作的实现

**链队列初始化**
```C
Status InitQueue(LinkQueue *Q) { 
// 分配头结点（哨兵结点） 
Q->front = Q->rear = (QueuePtr)malloc(sizeof(QNode));
	if (!Q->front) { 
		printf(stderr, "内存分配失败\n");
		exit(OVERFLOW); 
	} 
// 头结点的 next 置空
Q->front->next = NULL; 
	return OK;
}
```

**链队的销毁**
```C
	Status DestroyQueue(LinkQueue *Q) {
    if (!Q) return ERROR;  // 检查队列指针是否有效
    QueuePtr p;
    while (Q->front) {
        p = Q->front->next;  // 保存下一个结点地址
        free(Q->front);       // 释放当前结点（C 语言用 free 而非 delete）
        Q->front = p;         // 指针指向下一个结点
    }
    Q->rear = NULL;  // 避免野指针（重要！）
    return OK;
}
```

**链队的入队**
```C
	Status EnQueue(LinkQueue *Q, QElemType e) {
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));  // 创建新结点
    if (!p) {
        printf(stderr, "内存分配失败\n");  // C 语言错误输出
        return ERROR;  // 返回错误状态
    }
    
    p->data = e;
    p->next = NULL;        // 新结点初始化
    
    Q->rear->next = p;     // 将新结点链接到队尾
    Q->rear = p;           // 更新队尾指针
    
    return OK;             // 返回成功状态
}
```

**链队的出队**
```C
	Status DeQueue(LinkQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) {
        return ERROR;  // 空队列
    }

    QueuePtr p = Q->front->next;  // 指向首元结点（要删除的结点）
    *e = p->data;                 // 保存数据（通过指针返回）

    Q->front->next = p->next;     // 绕过要删除的结点

    // 特殊情况：删除的是最后一个结点
    if (Q->rear == p) {
        Q->rear = Q->front;       // 队列置空
    }
    
    free(p);  
    return OK;
}
```

**求队头元素**
```C
	Status GetHead(LinkQueue Q,QElemType &e){
		if(Q.front == Q.raer){
			return ERROR;
		}
		e = Q.front->next->data;
		return OK;
	}
```

# 四、队列的总结
|**类别**|**顺序队列**|**链式队列（链表实现）**|
|---|---|---|
|**存储结构**|用数组实现，使用循环方式管理队头和队尾指针，内存连续|用链表实现，队头和队尾通过指针连接，节点动态分配内存|
|**空间利用**|预先分配固定大小数组，可能出现假溢出（循环利用避免空间浪费）|动态分配内存，空间利用灵活，无固定大小限制|
|**访问方式**|只能顺序访问，不能随机访问，入队在队尾，出队在队头|只能顺序访问，入队在链尾，出队在链头，操作灵活|
|**入队/出队效率**|入队和出队操作时间复杂度均为O(1)，但需处理循环指针|入队和出队操作时间复杂度均为O(1)，无循环指针限制|
|**内存管理**|需要连续内存空间，扩容复杂，且容量固定|动态分配和释放节点内存，适合队列长度动态变化|
|**实现复杂度**|实现简单，使用数组和两个指针，需注意循环边界条件|实现稍复杂，需要动态分配节点和维护两个指针（队头、队尾）|
|**优点**|1. 操作简单高效  <br>2. 适合队列长度已知且变化不大|1. 动态空间分配，灵活  <br>2. 无固定容量限制  <br>3. 适合长度动态变化的队列|
|**缺点**|1. 容量固定，可能溢出  <br>2. 需要连续内存空间|1. 额外指针占用内存  <br>2. 实现复杂，需注意内存管理|
|**适用场景**|1. 队列长度稳定且可预估  <br>2. 对内存连续性要求高|1. 队列长度动态变化大  <br>2. 需要频繁入队和出队操作|